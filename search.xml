<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hosting code coverage report for a project targeting multiple Python versions by Travis CI and Github Pages</title>
      <link href="/blog/2020/02/26/travis_ci_for_multi_py_coverage/"/>
      <url>/blog/2020/02/26/travis_ci_for_multi_py_coverage/</url>
      
        <content type="html"><![CDATA[<p>In the past few days, I was finding a solution for:</p><ol><li>running tests with code coverage for a project targeting multiple Python versions automatically</li><li>public and easily accessible coverage report</li></ol><p>To meet the requirements of point 1, we can run <a href="https://github.com/pytest-dev/pytest" target="_blank" rel="noopener">pytest</a> and <a href="https://github.com/pytest-dev/pytest-cov" target="_blank" rel="noopener">pytest-cov</a> (in which <a href="https://github.com/nedbat/coveragepy" target="_blank" rel="noopener">coverage.py</a> is integrated) on <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>.</p><p>And thanks for the powerful <a href="https://github.com/nedbat/coveragepy" target="_blank" rel="noopener">coverage.py</a>, it is easy to generate a summarized report of code coverage for multiple Python versions by the following steps:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Just run this command repeatedly for each virtual environment ---</span></span><br><span class="line">$ COVERAGE_FILE=[name_of_coverage_file] python -mpytest --cov=[module_name] ./tests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, use this command to combine data files.</span></span><br><span class="line"><span class="comment"># Note that name of data file should be in the format of `.coverage.[suffix]`</span></span><br><span class="line"><span class="comment"># ref: https://coverage.readthedocs.io/en/coverage-5.0.3/cmd.html#combining-data-files</span></span><br><span class="line">$ python -mcoverage combine</span><br></pre></td></tr></table></figure><p>As for point 2, it took me a while to make a decision. Though there are several existing awesome services like <a href="https://codecov.io/" target="_blank" rel="noopener">codecov</a>, <a href="https://coveralls.io/" target="_blank" rel="noopener">coverall</a>, I wonder if I could achieve it without those services.</p><p>To do that, I have to figure out a way to access data files of code coverage generated in each single CI job (environment). However, it’s unlike Jenkins and CircleCI, you cannot access/share artifacts generated by jobs by simply adding some operations in your <code>.travis.yml</code>. Though it’s a general concept of CI jobs and it’s also stated in <a href="https://docs.travis-ci.com/user/build-stages/#data-persistence-between-stages-and-jobs" target="_blank" rel="noopener">official documentation</a>:</p><blockquote><p>It is important to note that jobs do not share storage, as each job runs in a fresh VM or container. If your jobs need to share files (e.g., using build artifacts from the “Test” stage for deployment in the subsequent “Deploy” stage), you need to use an external storage mechanism such as S3 and a remote scp server.</p></blockquote><p>Oh… Third party service is still required?</p><p>After rethinking about this problem, it seems <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> is a good candidate as a solution. However, it requires some interactions between Travis CI and Github. Therefore, I started googling with keywords like <code>travis ci push back to github</code>.</p><p>Then, yeah, a good article emerged from the sea: <a href="https://gist.github.com/willprice/e07efd73fb7f13f917ea" target="_blank" rel="noopener">How to set up TravisCI for projects that push back to github</a></p><p>It solved a part of problem. The remaining one is: <span style="color: orange">“How can I access those data files of code coverage after each CI job is done?”</span><br>It somehow seems that we are getting back to the starting point again. But, it isn’t.</p><p>Since we known that we could authorize Travis CI to push files back to our own Github repository, we could also playing with branches. Here is the strategy:</p><ol><li>Define a test stage containing jobs running tests on different Python version.</li><li>After a job is done, push the data file of code coverage back to specific branch.</li><li>While all tests are done, we enter to the next stage for combining data and generating report. In this stage, we checkout those data files from each branch for data storage.</li></ol><p>And I implemented it in <a href="https://github.com/NaleRaphael/travis-multi-py-coverage" target="_blank" rel="noopener">this repository</a>. All operations related to the strategy mentioned above are written in the file <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/utils.sh" target="_blank" rel="noopener">.travis/utils.sh</a>, and the workflows of running tests and generate report of code coverage are written in <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/runtests.sh" target="_blank" rel="noopener">.travis/runtests.sh</a> and <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/gen_report.sh" target="_blank" rel="noopener">.travis/gen_report.sh</a> respectively.</p><p>There are few things worth noting:</p><ul><li><p><code>create_branch_for_coverage</code><br>We create <span style="color: orange">orphan branches</span> for tracking coverage files only. And the argument <code>--orphan</code> make these branches being history-independent to the main branch (master) of our project. It’s a cool technique for such purpose, and there are more <a href="https://stackoverflow.com/a/13203015" target="_blank" rel="noopener">cool use cases here</a>.</p></li><li><p><code>pull_branch_for_coverage</code><br>By default, Travis CI pulls only <span style="color: orange">one branch</span> into docker container of a job (if it is triggered by <code>master</code> branch, then it pulls that branch).<br>Therefore, to commit code coverage data to corresponding branch, we have to pull that branch to local first. And that’s why you can see this function is called in both <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/runtests.sh" target="_blank" rel="noopener">.travis/runtests.sh</a> and <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/gen_report.sh" target="_blank" rel="noopener">.travis/gen_report.sh</a>.</p></li><li><p><code>commit_artifacts</code><br>Argument <code>--allow-empty</code> in command <code>git-commit</code> is necessary for this workflow, because there might be no changes in code coverage. e.g. commits for fixing typo, documentation…</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">commit_artifacts</span></span>() &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    git commit -q --allow-empty -m <span class="string">"Travis build: <span class="variable">$TRAVIS_BUILD_NUMBER</span>"</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>use argument <code>-q</code> to silence output message<br><span style="color: red">For security reasons.</span> As <a href="https://gist.github.com/willprice/e07efd73fb7f13f917ea#gistcomment-1845535" target="_blank" rel="noopener">this comment</a> from that post created by willprice.</p></li></ul><p>After setting up all these things and push them to Github, Travis should be ready and work normally. And you can check the coverage report hosted on Github Pages of your repository (which should be <code>https://[your_github_user_name].github.io/[repo_name]</code>)</p><hr><p>In conclusion, it is a nice experience for me to explore more things related to continuous intergration and Git. Though it might not be a elegant solution, but it did make me learn many things from it.</p>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> ci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMA-262-3: chapter 4 - scope chain</title>
      <link href="/blog/2019/10/01/ECMA-262-3_ch_4/"/>
      <url>/blog/2019/10/01/ECMA-262-3_ch_4/</url>
      
        <content type="html"><![CDATA[<p>原文連結：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">ECMA-262-3: chapter 4 - scope chain</a></p><p>以下內容會照著原文的架構書寫，並加入個人的解讀與其他相關的內容進去（定位不是翻譯文）。</p><h2 id="introduction"><a class="header-anchor" href="#introduction"></a>Introduction</h2><blockquote><p>As we already know from the <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="noopener">second chapter</a> concerning the <em>variable object</em>, the data of an <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="noopener">execution context</a> (variables, function declarations, and <strong>formal parameters</strong>* of functions) are stored as properties of the variables object.</p></blockquote><p>* 即 function signature 中的參數名稱，可見 MDN 的這篇關於 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_formal_parameter" target="_blank" rel="noopener">SyntaxError: missing formal parameter</a> 的說明</p><blockquote><p>Also, we know that the variable object is created and filled with initial values every time on <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#entering-the-execution-context" target="_blank" rel="noopener">entering the context</a>, and that its updating occurs at <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#code-" target="_blank" rel="noopener">code execution</a> phase.</p></blockquote><p>這段講到的東西其實就是我們常聽到的一個概念： hoisting 。<br>每當進入一個 execution context （以下簡稱 EC ）時， variable object （以下簡稱 VO ）就會被建立出來並把該 scope 內的變數設為本身的 property 並初始化（設定為 undefined）。而在進入執行階段後才會更新 VO 內的各項 property。</p><p>而本章節主要在說明 EC 裡面的一個細節，也就是 <code>scope chain</code> 。</p><h2 id="definition"><a class="header-anchor" href="#definition"></a>Definition</h2><p>在講到 <code>scope chain</code> 之前，我們要知道什麼是 <code>scope</code> 。從比較簡單一點的角度來看，你可以想像成是下面這句話：</p><blockquote><p>「你目前處於什麼位置，在你的視野裡能看到哪些東西？」</p></blockquote><p>中的<code>視野</code>。是的，也跟 <code>scope</code> 這個單字的意義一樣。</p><p>也就是說，如果你現在站在三年一班的的講台上，那你應該是看不到三年二班的杰倫同學才對。因為你的視野就是被限制在三年一班的環境裡，除非這兩個班之間的牆被打了個洞，或是教室的蓋法比較特殊，造成類似 <a href="https://stackoverflow.com/questions/4198906" target="_blank" rel="noopener">Python 2 中的 list comprehension 裡的變數洩漏</a>這項問題。</p><!-- 這時，廣播響起了訓導主任的聲音說道要找杰倫同學，而你也想去訓導處看看是發生了什麼事情。在還沒反應過來時，你身邊的一個藍色貓型機器人從他的口袋拿出了一個字卡，上面寫著： `scope chain` 。是的，如果你不知道訓導處在哪棟大樓，那麼你要怎麼到達那裡呢？而你想到，訓導處是屬於學校底下的一個處室，所以應當能夠從校園地圖中找到訓導處的位置。而這也像是 `scope chain` 的功能：它會幫你由上而下地紀錄 scope 的順序（學校 -> 某大樓 -> 訓導處）， --><ul><li><p>補充：<br>在 Python 中，對 scope 的解析順序也是有先後之分的，依序為 <code>Local -&gt; Enclosed -&gt; Global -&gt; Built-in</code> ，其中 <code>Enclosed</code> 其實就是 <code>closure</code> 的概念。<br>而這個概念其實可以類比到這篇所提到的 <code>scope chain</code> ，因為都是在處理一個 scope 中的物件指向的是哪個東西。<br>也因為有這樣的解析順序，所以在 Python 中可以見到一些對 <code>import</code> 進來的物件再次做更細節的綁定，讓物件處於更貼近執行期間的 scope ，也減少變數名稱的解析時間（相對地增加效能）。<br>而關於 Python 對於 scope 的解析，除了<a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" target="_blank" rel="noopener">官方文件</a>以外，也可以仔細咀嚼一下這篇文章 <a href="http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html" target="_blank" rel="noopener">A Beginner’s Guide to Python’s Namespaces, Scope Resolution, and the LEGB Rule</a> 。</p>  <!-- TODO: check numpy source code --></li></ul><p>回到原文，由於我們知道 ECMAScript 允許我們在 function 裡面再建立一個 function ，並能將內層的那個 function 當作回傳值傳出，所以我們可以實作出下方範例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()()  <span class="comment">// console: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because:</span></span><br><span class="line"><span class="comment">// step 1:</span></span><br><span class="line"><span class="comment">//   foo()()</span></span><br><span class="line"><span class="comment">//   &lt;---&gt; which returns `bar`</span></span><br><span class="line"><span class="comment">// step 2:</span></span><br><span class="line"><span class="comment">//     bar()</span></span><br><span class="line"><span class="comment">//     &lt;---&gt; which executes `alert(x + y)`</span></span><br><span class="line"><span class="comment">//   a. While `y` does not exist in the scope of `bar`</span></span><br><span class="line"><span class="comment">//   but inside the scope of `foo`, we got `y` with the value `20`.</span></span><br><span class="line"><span class="comment">//   b. While `x` does not exist in the scope of `bar` and `foo`</span></span><br><span class="line"><span class="comment">//   but inside the scope of `global`, we got `x` with the value `10`.</span></span><br><span class="line"><span class="comment">//   c. Thus, `x + y` is `10 + 20`.</span></span><br></pre></td></tr></table></figure><p>之所以做到這個效果，是因為每個 EC 都有它自己的 VO （對於被呼叫的函數，則是建立 activated object ，以下簡稱 AO）。 EC 是隨著執行步驟一層一層地建立出來，而 VO/AO 也是同時跟著一層一層的串起。所以對於上面範例而言， “bar” 的 scope chain 就包含了： AO(bar), AO(foo), VO(global) 。</p><p>這也對應到原文中的引言：</p><blockquote><p><em>Scope chain</em> is related with an execution context a <em>chain of variable objects</em> which is used for variables lookup at <em>identifier resolution</em>*.</p></blockquote><p>* <code>identifier resolution</code> ：也就是名稱的解析。我們須藉著 scope chain 去解析出目前執行到的某個 identifier 到底是什麼。而關於 identifier 的定義，可以往回看 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener">ECMA-262-3-chapter-3-this</a> 裡面的說明，或是參考下一段的解說。</p><p>接著：</p><blockquote><p>The scope chain of a function context is created at function <em>call</em>* and consists of the <em>activation object</em> and the internal <em>[[Scope]]</em> property of this function.</p></blockquote><p>* scope chain 的建立是在一個函數<strong>被呼叫</strong>的時候</p><p>所謂的 <code>[[Scope]]</code> property ，是被定義在一個 activated EC 裡面的，紀錄著該 EC 能夠用來做 <code>identifier resolution</code> 的 scope chain ，其可以視為以下的一個物件架構：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">  VO: &#123;...&#125;,  <span class="comment">// or AO</span></span><br><span class="line">  <span class="keyword">this</span>: thisValue,</span><br><span class="line">  Scope: [  <span class="comment">// Scope chain</span></span><br><span class="line">    <span class="comment">// list of all variable objects</span></span><br><span class="line">    <span class="comment">// for identifiers lookup (identifier resolution)</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="anchor-scope-definition" style="visibility:hidden;"></h6><p>而 <code>Scope</code> 可以被定義為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = AO + [[Scope]]</span><br></pre></td></tr></table></figure><p>若要以 ECMAScript 裡的物件來表示的話，我們可以分別：</p><ol><li><p>用 <code>array</code> 表示*：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Scope = [VOn, ..., VO2, VO1]; <span class="comment">// scope chain</span></span><br></pre></td></tr></table></figure><p>* 這邊 VO 的編號順序刻意與原文顛倒，是為了配合<a href="#function-activation">下文</a>所述的 VO 建立順序（數字越小代表越外層，也就是越早被建立的 VO）</p></li><li><p>用帶有 <code>__parent__</code> 的 <code>object</code> 表示：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;;</span><br><span class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;;</span><br><span class="line"><span class="comment">// etc.</span></span><br></pre></td></tr></table></figure></li></ol><p>另外原文提到：在 <code>ECMA-262-3 specification 10.1.4</code> 裡也有用 “a scope chain is a <em>list</em> of objects” 來描述，但暫時不理會在實作的層面上使用一個帶有 <code>__parent__</code> 的階層鍊也是一個作法，使用 <code>array</code> 來表示也是個比較貼近 <code>list</code> 的概念，所以原文以下都會使用這種方式來敘述。</p><h2 id="function-life-cycle"><a class="header-anchor" href="#function-life-cycle"></a>Function life cycle</h2><p>函數的生命週期可以被區分為 creation 和 activation (call) 兩個階段，以下就分別對這兩個階段進行討論。</p><h3 id="function-creation"><a class="header-anchor" href="#function-creation"></a>Function creation</h3><blockquote><p><em>[[Scope]]</em> is a hierarchical chain of all <em>parent</em> variable objects, which are above the current function context; the chain is saved to the function at its <em>creation</em>*.</p></blockquote><blockquote><p>Another moment which should be considered is that <em>[[Scope]]</em> in contrast with <em>Scope (Scope chain)</em> is the property of a <em>function</em> instead of a <em>context</em>**.</p></blockquote><p>* <code>[[Scope]]</code> 是在函數建立的階段就被建立出來，是靜態/不可變的（原文： statically/invariably），直到函數被摧毀（原文：function destruction）才消失。</p><p>** <code>[[Scope]]</code> 是函數的 property 而不是 context 的 property 。亦即：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">  globalContext.VO  <span class="comment">// === Global</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="function-activation"><a class="header-anchor" href="#function-activation"></a>Function activation</h3><blockquote><p>High light here is that the activation object is the <em>first</em> element of the <em>Scope</em> array, i.e. added to the <em>front of scope chain</em>*:</p></blockquote><h6 id="anchor-scope-chain-creation-order" style="visibility:hidden;"></h6><p>* 當前被執行到的函數所建立的 AO 會是該 <code>scope chain</code> 的<span style="color:red">第一個</span>，也就如同<a href="#anchor-scope-definition">上方所述</a>。而 <code>scope chain</code> 也可以表示為以下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = AO|VO + [[Scope]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Scope = [AO].concat([[Scope]])</span><br></pre></td></tr></table></figure><p>這對於 <code>identifier resolution</code> 是一個非常重要的特性，因為在做解析時，我們必須從當前的 scope 開始尋找，只有在找不到對應的 identifier 時才會往上一層 scope （更大的 scope ，同時也是 scope chain 的下一個）開始搜尋，否則 identifier 的對照會被打亂。而 <code>identifier resolution</code> 在原文中的定義為：</p><blockquote><p><em>Identifier resolution</em> is a process of determination to which <strong>variable object</strong> in scope chain the variable (or the function declaration) belongs.</p></blockquote><p><code>identifier resolution</code> 這個演算法的回傳值會是一個 <code>Reference</code> 物件，詳情可以往回參考 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/#-reference-type" target="_blank" rel="noopener">Chapter 3. This - 4.1 Reference type</a> 或是 chapter 3 筆記的<a href="/8di-0eIeQF2FTPSjx_uLEA#Reference-type">這部分</a>。</p><p>而 <code>identifier resolution</code> 解析的順序，如同上面所說的，會從當前被執行到的函數所建立的 <code>AO</code> 開始做（也就是最深層的那個 scope），再依序往更上層去搜索。所以可以大概地視為下方這樣的行為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- definition of VO ---</span></span><br><span class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;;  <span class="comment">// top scope</span></span><br><span class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> AO = &#123;<span class="attr">__parent__</span>: VOn, ... other data&#125;;    <span class="comment">// bottom scope</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- definition of scope chain ---</span></span><br><span class="line"><span class="comment">//      bottom      -&gt;      top</span></span><br><span class="line">Scope = [AO, VOn, ..., VO2, VO1]</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- algorithm of `identifier resolution` ---</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveIdentifier</span>(<span class="params">scopeChain, identifier</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentScope = scopeChain[<span class="number">0</span>]  <span class="comment">// start from `AO`</span></span><br><span class="line">  <span class="keyword">var</span> target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentScope &amp;&amp; !target) &#123;  <span class="comment">// if no scope can be explored or target is found, stop iteration</span></span><br><span class="line">    target = findIdentifier(currentScope, identifier)  <span class="comment">// if target is not found, return `null`</span></span><br><span class="line">    currentScope = currentScope.__parent__  <span class="comment">// update scope to be explored</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Reference.from(target)  <span class="comment">// convert `target` to an object of `Reference` type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- TODO: more details about scope chain and identifier resolution --><!-- TODO: brief introduction of identifier resolution in Python --><p>回到原文舉的例子，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step_01</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// step_03</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z)  <span class="comment">// step_05</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar()  <span class="comment">// step_04</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// step_02</span></span><br></pre></td></tr></table></figure><p>先記住重點：</p><ul><li>在 function creation 時：建立 <code>function.[[Scope]]</code></li><li>在 function call 時：建立 <code>activation object</code> 和 <code>scope chain</code></li></ul><p>再來我們看上面這個範例的執行流程：</p><ul><li><p>step_01: from the beginning; <code>foo</code> is created (<a href="#function-creation">creating <code>foo.[[Scope]]</code></a>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// variable object of `global` context</span></span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  foo: &lt;reference to function&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// at `foo` creation</span><br><span class="line">foo.[[Scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>step_02: After <code>foo</code> is called (creating creating activation object and <a href="#function-activation">scope chain</a> of <code>fooContext</code>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activation object of `foo` context:</span></span><br><span class="line">fooContext.AO = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  bar: &lt;reference to function&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// scope chain of `foo` context:</span><br><span class="line">fooContext.Scope = fooContext.AO + foo.[[Scope]]</span><br><span class="line">// i.e.: </span><br><span class="line">fooContext.Scope = [fooContext.AO, globalContext.VO]</span><br></pre></td></tr></table></figure></li><li><p>step_03: At creation of inner <code>bar</code> function (<a href="#function-creation">creating <code>bar.[[Scope]]</code></a>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bar.[[Scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>step_04: at <code>bar</code> function call (creating activation object and <a href="#function-activation">scope chain</a> of <code>barContext</code>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activation object of `bar` object</span></span><br><span class="line">barContext.AO = &#123;</span><br><span class="line">  z: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scope chain of `bar` context:</span></span><br><span class="line">barContext.Scope = barContext.AO + bar.[[Scope]]</span><br><span class="line"><span class="comment">// i.e.:</span></span><br><span class="line">barContext.Scope = [barContext.AO, fooContext.AO, globalContext.VO]</span><br></pre></td></tr></table></figure></li><li><p>step_05:<br>綜合以上， <code>identifier resolution</code> 的結果為：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &quot;x&quot;</span><br><span class="line">-- barContext.AO // not found</span><br><span class="line">-- fooContext.AO // not found</span><br><span class="line">-- globalContext.VO // found - 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- &quot;y&quot;</span><br><span class="line">-- barContext.AO // not found</span><br><span class="line">-- fooContext.AO // found - 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- &quot;z&quot;</span><br><span class="line">-- barContext.AO // found - 30</span><br></pre></td></tr></table></figure><p>因此， <code>console.log(x + y + z)</code> 的結果為 <code>60</code></p></li></ul><h2 id="scope-features"><a class="header-anchor" href="#scope-features"></a>Scope features</h2><p>以下內容則是討論在 ECMAScript 中，有哪些特色是和函數的 <code>[[Scope]]</code> 有關。</p><h3 id="closures"><a class="header-anchor" href="#closures"></a>Closures</h3><blockquote><p>Actually, a <em>closure</em> is exactly a <em>combination of a function code and its [[Scope]] property</em>.</p></blockquote><blockquote><p>Thus, [[Scope]] contains that <em>lexical environment</em> (the parent variable object) in which function is <em>created</em>. Variables from higher contexts at the further function activation will be searched in this lexical (statically saved at creation) chain of variable objects.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span></span><br><span class="line">  foo()  <span class="comment">// 10, not 20</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>以上述範例而言，在做 <code>identifier resolution</code> 的過程如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext.VO = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  foo: &lt;reference to function&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.[[Scope]] = [globalContext.VO]</span><br><span class="line"></span><br><span class="line">// --- after that IIFE is executed ---</span><br><span class="line">iifeContext.AO = &#123;</span><br><span class="line">  x: 20</span><br><span class="line">&#125;</span><br><span class="line">iifeContext.Scope = [iifeContext.AO, globalContext.VO]</span><br><span class="line"></span><br><span class="line">// --- when `foo` is called, it try to resolve `x` from `foo.Scope`</span><br><span class="line">fooContext.AO = &#123;&#125;</span><br><span class="line"></span><br><span class="line">// scope chain of `foo` context</span><br><span class="line">fooContext.Scope = fooContext.AO + foo.[[Scope]]</span><br><span class="line">// i.e.:                 ↓ here is the `x` we want to find</span><br><span class="line">fooContext.Scope = [&#123;&#125;, &#123;x:10, foo: &lt;reference to function&gt;&#125;]</span><br></pre></td></tr></table></figure><p>因此 <code>foo</code> 裡面的 <code>console.log(x)</code> 輸出的值仍是原本位於 global scope 的 <code>x</code> 的值。<br>簡而言之，就是因為 <code>foo</code> 的 <code>[[Scope]]</code> 早在自己被建立時就被確定了，而當時它的視野內能看到的就只有 <code>var x = 10</code> ，所以即使後來在 IIFE 內被呼叫到，也不會因為有一個同名的 <code>x</code> 而解析成新的這個 <code>x</code>。</p><p>而另一個經典的 closure 範例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x, y])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">30</span></span><br><span class="line"><span class="keyword">var</span> bar = foo()  <span class="comment">// anonymous function is returned</span></span><br><span class="line"></span><br><span class="line">bar()  <span class="comment">// [10, 20]</span></span><br></pre></td></tr></table></figure><blockquote><p>Moreover, this example clearly shows that <code>[[Scope]]</code> of a function (in this case of the anonymous function returned from function <code>foo</code>) continues to exist <em>even after the context in which a function is created is already finished</em>.</p></blockquote><p>原文用這個例子來說明：我們可以從上述例子發現，即使在 <code>foo</code> 函數執行完畢後，其回傳的匿名函數的 <code>[[Scope]]</code> 還是一直存在著的。而這也是 clousure 的特色之一：它可以保留內部函數被建立時的 Scope*，且不被外部的 identifier 影響**！</p><p>* 前面提到的重點，在 function creation 時：建立 <code>function.[[Scope]]</code>。所以在上述例子中，匿名函數被建立時，它的 <code>[[Scope]]</code> 為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">anonymousContext.[[Scope]] = [fooContext.AO, globalContext.VO]</span><br><span class="line"><span class="comment">// i.e.:</span></span><br><span class="line">anonymousContext.[[Scope]] = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">foo</span>: &lt;reference to function&gt;, x: 30, bar: undefined&#125;]</span><br></pre></td></tr></table></figure><p>** 因為每次在 scope chain 被建立時，<a href="#anchor-scope-chain-creation-order">都會把當前被 activated 的 scope 加到 scope chain 的最前面</a>，所以在做 <code>identifier resolution</code> 時，就可以從相對應的 activated context 的 scope 開始找起。也因此即使更外層有同名的 identifier 時，也不會解析成外層的那個 identifier 。</p><p>而關於 closure 更細節的討論，可以見<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">原文的第六章</a>。</p><h3 id="scope-of-functions-created-via-function-constructor"><a class="header-anchor" href="#scope-of-functions-created-via-function-constructor"></a>[[Scope]] of functions created via <code>Function</code> constructor</h3><p>但是這裡一個例外情況需要注意。當我們使用 <code>Function</code> 建構子在一個 closure 內建立一個函數時，會有這樣的情況：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">barFD</span> </span>&#123;  <span class="comment">// function declaration</span></span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> barFE = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// function expression</span></span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> barFn = <span class="built_in">Function</span>(<span class="string">'console.log(x); console.log(y);'</span>)</span><br><span class="line"></span><br><span class="line">  barFD()  <span class="comment">// 10, 20</span></span><br><span class="line">  barFE()  <span class="comment">// 10, 20</span></span><br><span class="line">  barFn()  <span class="comment">// 10, "ReferenceError: y is not defined"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>由上述例子可以發現，在 <code>barFn</code> 裡面的 <code>y</code> 並無法被存取到，而造成 <code>ReferenceError</code> 。我們回到原文繼續看：</p><blockquote><p>But it does not mean that function <code>barFn</code> has no internal <code>[[Scope]]</code> property (else it would not have access to the variable <code>x</code>)*.</p></blockquote><p>* 這並不代表透過 <code>Function</code> 建構子所建立的 <code>barFn</code> 就沒有了 <code>[[Scope]]</code> （否則在內部也無法存取到更上層的 <code>x</code> ）</p><blockquote><p>And the matter is that <code>[[Scope]]</code> property of functions created via the Function constructor contains <em>always only the global object</em>*.</p></blockquote><p>* 當我們使用 <code>Function</code> 建構子來動態地建立一個函數時，那個被建立出來的函數的 <code>[[Scope]]</code> <span style="color:red;">只會有 <code>global</code> 的 scope </span>。關於這點，可見 <a href="https://www-archive.mozilla.org/js/language/E262-3.pdf#%5B%7B%22num%22%3A731%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22FitB%22%7D%5D" target="_blank" rel="noopener">ECMAScript specification 3 - 15.3.2.1</a> 中的第 16 步（關鍵在下方引述的粗體字部分）：</p><blockquote><ol start="16"><li>Create a new Function object as specified in section 13.2 with parameters specified by parsing <em>P</em> as a $FormalParameterList_{opt}$ and boday specified by parsing <em>body</em> as a <em>FunctionBody</em>. <strong>Pass in a scope chain consisting of the global object as the <em>Scope</em> parameter.</strong></li></ol></blockquote><p>而關於透過 <code>Function</code> 建構子所建立出的函數與 closure 的討論，可以再參考<a href="https://www.bennadel.com/blog/1909-javascript-function-constructor-does-not-create-a-closure.htm" target="_blank" rel="noopener">這篇文章</a>。</p><h3 id="two-dimensional-scope-chain-lookup"><a class="header-anchor" href="#two-dimensional-scope-chain-lookup"></a>Two-dimensional Scope chain lookup</h3><p>關於 scope chain 用於 <code>identifier resolution</code> 上的細節，還有一個重點需要注意：</p><blockquote><p>… prototypes (if they are) of <strong>variable objects</strong> can be also considered — because of prototypical nature of ECMAScript: if property is not found directly in the object, its lookup proceeds in the <em>prototype chain</em>.</p></blockquote><p>記得 ECMAScript 是一個 prototype-based 語言嗎？我們討論的 VO 也是一個物件，所以當我們無法在 VO 裡面找到 property 的話，也會依照 prototype 的特性：往該物件的 prototype 去搜尋是否有該 property 。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dynamically add a property `x` to the prototype of `Object`</span></span><br><span class="line"><span class="comment">// Note that this operation affects all objects, use this carefully.</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No property `x` found in `foo`, so it continues to search in prototype of `foo`.</span></span><br><span class="line"><span class="comment">// (And type of `x` is `function`. However, `function` is also an `object`)</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.x)  <span class="comment">// hence we got `1` here</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dynamically add a property `x` to the prototype of `Object`</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span></span><br><span class="line"><span class="comment">// We can also add a property `x` to the prototype of `Function`</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.x = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because the prototype chain of `foo` is:</span></span><br><span class="line"><span class="comment">// foo.__proto__: `Function`</span></span><br><span class="line"><span class="comment">// -&gt; foo.__proto__.__proto__: `Object`</span></span><br><span class="line"><span class="comment">// `Function` is the first element in this prototype chain, so that it will be resolved first</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.x)  <span class="comment">// hence we got `3` here</span></span><br></pre></td></tr></table></figure><p>所以原文提到，這也可看作是一個 2D 的 scope chain 搜尋：</p><ol><li>on scope chain links → 優先對每個 scope chain 上的 AO/VO 做搜尋</li><li>on every of scope chain link — deep into on prototype chain links → 如果在第一步都找不到目標，才會再對每個 scope chain 上 AO/VO 的 prototype chain 做更深入的搜尋</li></ol><p>但是因為 AO 並沒有 prototype ，所以我們在以下的範例可以看到這樣的輸出：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>在上述例子中，我們可以發現 <code>bar</code> 裡面的 <code>x</code> 並不是 <code>Object.prototype.x</code> 的值，而是位於 <code>foo</code> 裡面的 <code>x</code> 。這也證明了 <code>identifier resolution</code> 是優先搜索 scope chain ，如果沒有搜尋到結果才會再從 prototype chain 去尋找。同時也證明了：如果 <code>barContext.AO</code> 有 prototype ，那 <code>x</code> 的值會是 10 才對。</p><ul><li><p>補充：以上個範例來說，若以同樣的作法，我們把 <code>Object.prototype.x = 10</code> 改為 <code>Function.prototype.x = 10</code> ，並把 <code>foo</code> 裡面的 <code>var x = 20</code> 拿掉，結果為何？</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.x = <span class="number">10</span></span><br><span class="line">foo()  <span class="comment">// output: ???</span></span><br></pre></td></tr></table></figure>  <details>      <summary><span style="color:green; font-weight:bold;">Click me to reveal the answer</span></summary>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p>此時的 <code>Function.prototype.x = 10</code> 並沒有作用，但是若改為 <code>Object.prototype.x = 10</code> 則又能得到 <code>10</code> 的結果。這點值得再深入討論…（因為這可能與不同的 JavaScript 實作有關，所以從 source code 去找原因才會是根本之道）</p>  </details></li></ul><h3 id="scope-chain-of-the-global-and-eval-contexts"><a class="header-anchor" href="#scope-chain-of-the-global-and-eval-contexts"></a>Scope chain of the global and eval contexts</h3><p>這部分的話就沒有什麼特別有趣的東西囉，但是仍需要注意的是：</p><blockquote><p>The scope chain of the global context contains <em>only global object</em>. The context with code type “eval” has the same scope chain as a <em>calling context</em>.</p></blockquote><p>也就是說：</p><ol><li><p>global context 的 scope chain 只有 <code>global</code> object</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext.Scope = [Global]</span><br></pre></td></tr></table></figure></li><li><p>對於 <code>eval()</code> 所產生的內容，其 context 的 scope chain 跟 <code>callingContext</code> 相同：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">evalContext.Scope === callingContext.Scope</span><br></pre></td></tr></table></figure></li></ol><h3 id="affecting-on-scope-chain-during-code-execution"><a class="header-anchor" href="#affecting-on-scope-chain-during-code-execution"></a>Affecting on Scope chain during code execution</h3><p>而在 ECMAScript 裡，有兩個方式可以在執行階段（原文： at runtime code execution phase ）影響 scope chain ：</p><ol><li><code>with</code> block</li><li><code>try ... catch...</code> block</li></ol><p>因為這兩個 statement 會在 scope chain 的最前面加上自己的 scope ，也就是類似以下的情況：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = withObject|catchObject + AO|VO + [[Scope]]</span><br></pre></td></tr></table></figure><p>這部分可參考 chapter 3 筆記的 <a href="/8di-0eIeQF2FTPSjx_uLEA#Reference-type-and-null-this-value">Reference type and null this value</a></p><p>以下，我們直接以原文中較複雜的那個例子來說明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span>  <span class="comment">// step_01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;) &#123;  <span class="comment">// step_02</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span>  <span class="comment">// step_03</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">// step_04: 30</span></span><br><span class="line">  <span class="built_in">console</span>.log(y)  <span class="comment">// step_05: 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// step_06: 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// step_07: 30</span></span><br></pre></td></tr></table></figure><p>會有這樣的輸出，是因為：</p><ul><li><p>step_01:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context of `global` is initialized</span></span><br><span class="line">globalContext.VO = &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in current scope</span></span><br><span class="line">Scope = [withObject, globalContext]</span><br></pre></td></tr></table></figure></li><li><p>step_02: entering <code>with</code> block</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">withObject = &#123;<span class="attr">x</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in current scope</span></span><br><span class="line">Scope = [withObject, globalContext]</span><br><span class="line"><span class="comment">// i.e.</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>step_03: variable declaration<br>對於 <code>with</code> 區塊內的變數宣告的動作來說，我們會先在 local scope 尋找是否已經有相同的 <code>identifier</code> ：</p><ul><li>若有，則將其更新為新的數值（一樣會經過 <code>identifier resolution</code> 的過程去搜尋 scope chain）。</li><li>若無，則在 local scope 內建立這個 <code>identifier</code> 並賦值。</li></ul>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for `var x = 30`:</span></span><br><span class="line"><span class="comment">//        ↓ `x` is updated</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// for `var y = 30`</span></span><br><span class="line"><span class="comment">//          ↓ not found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;]</span><br><span class="line"><span class="comment">//                        ↓ found here, so we update it</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>step_04:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//        ↓ `x` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>step_05:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//                        ↓ `y` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>step_06:<br>在離開 <code>with</code> 區塊後， <code>with</code> 所建立的 scope 會被移除掉，所以變成：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//       ↓ scope created by `with` is removed</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>step_07:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//        ↓ `x` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>step_08:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//               ↓ `y` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>補充：如果不是用 <code>with</code> 而是一般的 closure ，輸出則為：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">// 30</span></span><br><span class="line">  <span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li></ul><p>至於 <code>try ... catch ...</code> 區塊，我們常見的用法如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'yo'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ex)  <span class="comment">// Error: "yo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ex)  <span class="comment">// ReferenceError: ex is not defined</span></span><br></pre></td></tr></table></figure><p>其實在執行 <code>catch</code> 區塊時， scope chain 就會被修改成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> catchObject = &#123;</span><br><span class="line">  ex: &lt;exception object&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Scope = catchObject + AO|VO + [[Scope]]</span><br></pre></td></tr></table></figure><p>而在離開 <code>catch</code> 區塊後， <code>catch</code> 所建立的 scope 也會被移除掉，因此最後一行的結果是 <code>ReferenceError</code>。</p><h2 id="conclusion"><a class="header-anchor" href="#conclusion"></a>Conclusion</h2><p>在這個章節裡，我們討論到了許多關於 scope chain 的細節。基本上只要記住函數的生命週期中，分別在<a href="#function-creation">建立</a>與<a href="#function-activation">被呼叫(啟動)</a>時會做什麼處理，那麼後續對於 JavaScript 的執行流程和結果就不會有太大的問題了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMA-262-3: chapter 3 - this</title>
      <link href="/blog/2019/09/27/ECMA-262-3_ch_3/"/>
      <url>/blog/2019/09/27/ECMA-262-3_ch_3/</url>
      
        <content type="html"><![CDATA[<p>原文連結：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener">ECMA-262-3: chapter 3 - this</a></p><p>以下內容會照著原文的架構書寫，並加入個人的解讀與其他相關的內容進去（定位不是翻譯文）。</p><h2 id="introduction"><a class="header-anchor" href="#introduction"></a>Introduction</h2><blockquote><p>Many programmers are used to thinking that the <code>this</code> keyword in programming languages is closely related to the object-oriented programming, exactly referring the newly created object by the constructor. In ECMAScript this concept is also implemented, however, as we will see, here it is not limited only to definition of created object.</p></blockquote><p>其實在我第一次嘗試去了解 JavaScript 的 <code>this</code> 時，也有點陷入如上文所說的情況。雖然以物件導向的觀點來理解 <code>this</code> 確實有不小的幫助，但是如果沒有更深入了解 Javascript 的 <code>this</code> ，很容易就會誤用。<br>像是之前在試做一個 todo list 時，為了動態地將一個 object method 綁定到新建立的按鈕上後，在該 method 裡面可以用 <code>this</code> 去抓到 object 本身的其他 method 來處理事情，卻發現 <code>this</code> 指向的是按鈕而不是原本那個 method 所屬的 object。（可見下方範例或此<a href="https://codepen.io/naleraphael/pen/NWKVxBy" target="_blank" rel="noopener">連結(codepen)</a>）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"manager.show(this)"</span>&gt;</span>Button 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- after clicked --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; Object &#123; id: "manager" &#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; &lt;button id="btn1" onclick="manager.show(this)"&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span>Button 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- after clicked --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; &lt;button id="btn2"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; click &#123; target: button#btn2, buttons: 0, clientX: 114, clientY: 17, layerX: 114, layerY: 17 &#125; --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="string">'manager'</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  show (arg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> manager = <span class="keyword">new</span> Manager()</span><br><span class="line"><span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">'btn2'</span>)</span><br><span class="line">btn2.addEventListener(<span class="string">'click'</span>, manager.show, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><ul><li><p>補充:<br>JavaScript 中 <code>this</code> 的概念並不完全與 Python 的 <code>self</code> 一樣。<br>JavaScript 中 <code>this</code> 會指向實作的上一層對象，而 Python 的 <code>self</code> 則是用來表示物件方法(object method)內指向的物件本身（如同定義 <code>classmethod</code> ，一般 object method 的 signature 中第一個參數就是指向該 method 所綁定的物件本身）。<br>另外，Python 中的 <code>self</code> 並不是一個 builtin keyword ，只能算是一個<strong>約定成俗</strong>的一個慣用字，可見下方例子</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo2</span><span class="params">(me)</span>:</span></span><br><span class="line">    <span class="comment"># we can replace name of the first argument with another one</span></span><br><span class="line">    print(me)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  foo = Foo()</span><br><span class="line">  foo.echo()  <span class="comment"># &lt;__main__.Foo object at 0x7f12febd8a10&gt;</span></span><br><span class="line">  foo.echo2() <span class="comment"># &lt;__main__.Foo object at 0x7f12febd8a10&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="definition"><a class="header-anchor" href="#definition"></a>Definition</h2><blockquote><p><code>this</code> is directly related to the type of executable code of the context. The value is determined <em>on entering the context</em>* and is <em>immutable</em>** while the code is running in the context.</p></blockquote><p>* <code>this</code> 的值是在進入執行階段時才會被決定的，因此我們可以透過一些方式將一段有使用到 <code>this</code> 的程式碼重新綁定到其他物件上，使該段程式碼有不同的輸出。（後面會提到）<br>** <code>this</code> 是 immutable 的物件，也就是說一旦它的值被指定後，就無法再由後續的行為去改變那個值。</p><h2 id="this-value-in-the-global-code"><a class="header-anchor" href="#this-value-in-the-global-code"></a><code>this</code> value in the global code</h2><p>在 global scope 底下， <code>this</code> 指向的物件就是 <code>global object</code> 本身 (<code>Object [global]</code> in node.js, <code>Window</code> in browser)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// explicit property definition of the global object</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// console: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implicit definition via assigning to unqualified identifier</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// console: 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// also implicit via variable declaration because variable</span></span><br><span class="line"><span class="comment">// object of the global context is the global object itself</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.c);  <span class="comment">// console: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// equality check</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === global);  <span class="comment">// console: true; in node.js runtime</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// console: true; in browser</span></span><br></pre></td></tr></table></figure><h2 id="this-value-in-the-function-code"><a class="header-anchor" href="#this-value-in-the-function-code"></a><code>this</code> value in the function code</h2><blockquote><p>The first (and, probably, the main) feature of <code>this</code> value in this type of code is that here it is not <em>statically bound</em>* to a function.</p></blockquote><blockquote><p>As it has been mentioned above, <em><code>this</code> value is determined on entering the context</em>**, and in case with a function code the value can be absolutely different every time.</p></blockquote><p>*, ** 如同上面所說的，<code>this</code> 並不是靜態地被綁定在一個函數裡面，而是在進入一個 execution context 後才被決定。</p><blockquote><p>However, at runtime of the code <code>this</code> value is immutable, i.e. it is not possible to assign a new value to it since <code>this</code> is not a variable (in contrast, say, with <em>Python programming language and its explicitly defined <code>self</code> object which can repeatedly be changed at runtime</em>*)</p></blockquote><p>* Python 中的 <code>self</code> 是可以被重新綁定的，詳情請見下方範例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://repl.it/@naleraphael/pyobjectselfrebinding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.name = <span class="string">'Foo'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_my_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.name = <span class="string">'Bar'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_my_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self.name)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_my_name_proxy</span><span class="params">(self, target)</span>:</span></span><br><span class="line">    self = target   <span class="comment"># rebind `self` with another object</span></span><br><span class="line">    self.say_my_name()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  bar = Bar()</span><br><span class="line">  bar.say_my_name()  <span class="comment"># Bar</span></span><br><span class="line">  bar.say_my_name_proxy(Foo())  <span class="comment"># Foo</span></span><br></pre></td></tr></table></figure><p>回到原文，我們用以下的範例來說明 <code>this</code> 指向的對象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === bar)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this = foo  // &lt;- SyntaxError: invalid assignment left-hand side</span></span><br><span class="line">    <span class="comment">// console.log(this.x)  // the line above is failed to be compiled, so this line won't work</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情況 1:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bar.test()</span><br><span class="line"></span><br><span class="line">// Output in console</span><br><span class="line">true</span><br><span class="line">20</span><br></pre></td></tr></table></figure><ul><li>情況 2:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// rebind `bar.test` to the new property `test` of `foo` object</span><br><span class="line">// so that `this` in the function `test` will point to the object `foo`</span><br><span class="line">&gt; foo.test = bar.test</span><br><span class="line">&gt; foo.test()</span><br><span class="line"></span><br><span class="line">// Output in console</span><br><span class="line">false</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h6 id="section-this-value-in-function-call-quote-2" style="visibility:hidden;"></h6><p>再來，原文提到</p><blockquote><p>First, in a usual function call, <strong><code>this</code> is provided by the caller which activates the code of the context</strong>, i.e. the parent context which calls the function. And the value of this is determined by the form of a call expression (in other words by the form how syntactically the function is called).</p></blockquote><p>也就是說，在一般的函數呼叫形式下，一段 execution context (EC) 內的 <code>this</code> 是由啟動 (activate) 該 EC 的 caller 提供。而 <code>this</code> 的值則是由呼叫的形式 (form of a call expression) 決定，也就是該函數的呼叫方式。以下為原文的範例，說明了一個函數透過不同的呼叫方式會讓其中的 <code>this</code> 指向不同的物件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- example 01 ---</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// console: global (in node.js runtime); Window (in browser)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor)   <span class="comment">// console: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In this expression, the parent context of `constructor` is `foo.prototype`</span></span><br><span class="line">foo.prototype.constructor()  <span class="comment">// console: foo.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- example 02 ---</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar()  <span class="comment">// console: foo, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare an variable `exampleFunc`, and pass the address of `foo.bar` to it</span></span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc === foo.bar)  <span class="comment">// console: true, they point to the same address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In this expression, the parent context of `exampleFunc` is `global`</span></span><br><span class="line">exampleFunc()  <span class="comment">// console: global, false</span></span><br></pre></td></tr></table></figure><ul><li><p>補充 1:<br>接續上述的 example 02 ，如果我們又動態的改變了 <code>foo.bar</code> ，那麼 <code>exampleFunc()</code> 的輸出是？</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar</span><br><span class="line">exampleFunc()  <span class="comment">// console: global, false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Then, we update the function `foo.bar`</span></span><br><span class="line">foo.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'yo'</span>) &#125;</span><br><span class="line">foo.bar()  <span class="comment">// console: 'yo'</span></span><br><span class="line">exampleFunc()  <span class="comment">// console: ???</span></span><br></pre></td></tr></table></figure>  <details>      <summary>Answer</summary>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// console: global, false</span><br><span class="line">Reason:</span><br><span class="line">In the line ```var exampleFunc = foo.bar```,</span><br><span class="line">`example` got a copy of address of the function `foo.bar`.</span><br><span class="line">So that it won&apos;t be affected after `foo.bar` is updated.</span><br></pre></td></tr></table></figure>  </details></li><li><p>補充 2: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">Object.prototype.constructor | MDN</a></p></li></ul><h2 id="reference-type"><a class="header-anchor" href="#reference-type"></a>Reference type</h2><p><em>Spoiler: 本段可用來解釋上一段中 <code>foo()</code> 與 <code>foo.prototype.constructor()</code> 輸出結果不同的原因</em><br><em>Note: 這邊的 <code>Reference</code> 是對於 object 與其所在 scope 的描述，與 <code>pass by value / reference</code> 中的 <code>reference</code> 講的不是一樣的概念</em></p><p><code>Reference</code> type 可以用以下的虛擬程式碼來表示（當作一個物件來看待時）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</span><br><span class="line">  base: <span class="xml"><span class="tag">&lt;<span class="name">base</span> <span class="attr">object</span>&gt;</span>,  // base object of this object belongs</span></span><br><span class="line">  propertyName: &lt;property name&gt;,  // name of this object</span><br><span class="line">  // strict: &lt;boolean&gt;,  // added in ES5, it will be `true` when `strict mode` is enabled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>Reference</code> type 的值只會有兩種：<br>1. <code>identifier</code> (variable names, function names, names of function arguments and names of <em>unqualified properties</em>* of the global object; see also <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">Chapter 4. Scope chain</a>)<br>2. <code>property accessor</code></p><p>* unqualified properties: (待確認) 所謂的 <code>qualified property</code> 是指一個 <strong>可以被設定的 (configurable)</strong> 屬性。所以 <code>unqualified property</code> 也就是無法被設定的屬性。但是在這要注意，原文強調的是 <em>unqualified properties of the global object</em> ，所以可能表示：</p><pre><code>只有在隸屬於 global object 的 `unqualified property` 才可以被當作 `identifier`</code></pre><p>參考: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Delete_in_strict_mode#What_went_wrong" target="_blank" rel="noopener">Delete in strict mode | MDN</a></p><hr><p>所謂的 <code>identifier</code> ，以下列位於 global scope 底下的變數與函數為例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其在 <strong>操作的過程中</strong> (原文: intermediate results of operations) ，會被解析成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而當我們要從這些 <code>Reference</code> type 取得那些物件的實際值時，我們會透過一個像是以下虛擬程式碼的一個方法 <code>GetValue</code> 來達成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// see also: ES3 sepcification - 8.7.1 GetValue</span></span><br><span class="line"><span class="comment">// https://www-archive.mozilla.org/js/language/E262-3.pdf</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Type(value) != Reference) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> base = GetBase(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we can tell the cause of `ReferenceError` and `TypeError` by this?</span></span><br><span class="line">    <span class="comment">// - TypeError: a is undefined (e.g. `var a; a.b`)</span></span><br><span class="line">    <span class="comment">// - ReferenceError: a is not defined (e.g. `a`)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `[[Get]]`: returns the real value of object’s property, including as well</span></span><br><span class="line">  <span class="comment">// analysis of the inherited properties from a prototype chain</span></span><br><span class="line">  <span class="keyword">return</span> base.[[Get]](GetPropertyName(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>property accessor</code> ，也就是物件的屬性存取子，如下所示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo.a  <span class="comment">// &lt;- `a` is a property accessor of object `foo`</span></span><br><span class="line">foo[<span class="string">'a'</span>]  <span class="comment">// &lt;- `a` is a property accessor of object `foo`</span></span><br></pre></td></tr></table></figure><hr><p>而我們要如何決定一個 function context 內所使用到的 <code>this</code> 指的是誰呢？基本上我們可以照著以下的規則來決定：</p><blockquote><p>The value of <code>this</code> in a function context is provided <strong>by the caller and determined by the current form of a call expression</strong>* (how the function call is written syntactically).</p></blockquote><h6 id="anchor-call-parentheses" style="visibility:hidden;"></h6><blockquote><p>If on the left hand side from the call parentheses <code>( ... )</code>** , there is a value of <code>Reference</code> type then <code>this</code> value is set to the <em>base object</em> of this value of <code>Reference</code> type.</p></blockquote><blockquote><p>In all other cases (i.e. with any other value type which is distinct from the <code>Reference</code> type), <code>this</code> value is always set to <code>null</code>. But since there is no any sense in <code>null</code> for <code>this</code> value, it is <em>implicitly</em> converted to <em>global object</em>.</p></blockquote><p>* 其實就是前面原文有提到的: <em>And the value of this is determined by the form of a call expression (in other words by the form how syntactically the function is called).</em></p><p>** 也就是呼叫函數時的那個表示式中最後的那兩個小括弧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line"><span class="comment">// ↑ this</span></span><br></pre></td></tr></table></figure><p>所以綜合上述規則，最白話的講法就是：<br>先看函數呼叫的那段表示式中，函數的前面長什麼樣子：<br>1. 如果是 <code>a.b.func()</code> ，那麼 <code>this</code> 指的就是 <code>a.b</code> 的 <code>Reference</code> type 中的 <code>base</code> object<br>2. 如果是 <code>func()</code> ，那麼 <code>this</code> 則為 <code>null</code>。（但會根據 runtime 的不同而有不一樣的預設值，像是在 node.js 中為 <code>global</code> ，瀏覽器中為 <code>Window</code>）</p><p>再以原文中的三個例子來看，就可以知道為何 <code>this</code> 會是那樣的值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- example 01 ---</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reference` type of `foo`:</span></span><br><span class="line"><span class="comment">// var fooReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: global,</span></span><br><span class="line"><span class="comment">//   propertyName: 'foo'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">foo()  <span class="comment">// console: global</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- example 02 ---</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reference` type of `foo.bar`:</span></span><br><span class="line"><span class="comment">// var fooBarReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: foo,</span></span><br><span class="line"><span class="comment">//   propertyName: 'bar'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">foo.bar()  <span class="comment">// console: foo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- example 03 ---</span></span><br><span class="line"><span class="keyword">var</span> test = foo.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reference` type of `test`:</span></span><br><span class="line"><span class="comment">// var fooReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: global,</span></span><br><span class="line"><span class="comment">//   propertyName: 'test'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">test()  <span class="comment">// console: global</span></span><br></pre></td></tr></table></figure><p>回到上一段（<code>this</code> value in the function code）的例子，我們也就可以知道為何 <code>foo.prototype.constructor()</code> 會印出 <code>foo.prototype</code> 了，因為其 <code>Reference</code> type 為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</span><br><span class="line">  base: foo.prototype,</span><br><span class="line">  propertyName: <span class="string">'constructor'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>因此，我們也可以利用 <code>this</code> 的這些機制，達成以下的功能：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">bar</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> y = &#123;<span class="attr">bar</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind `foo` to the property `test` of each object</span></span><br><span class="line">x.test = foo</span><br><span class="line">y.test = foo</span><br><span class="line"></span><br><span class="line">x.test() <span class="comment">// 10</span></span><br><span class="line">y.test() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>而這樣的機制，也可以幫助我們做出類似 <code>Vue.js</code> 中所謂的 <code>computed property</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aBagOfSand = &#123;</span><br><span class="line">  weight: <span class="number">1500</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeightInGram</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`weight: <span class="subst">$&#123;<span class="keyword">this</span>.weight&#125;</span> (g)`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeightInKilogram</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`weight: <span class="subst">$&#123;<span class="keyword">this</span>.weight<span class="regexp">/1000&#125; (kg)`)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInGram = getWeightInGram</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInKilogram = getWeightInKilogram</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInGram()  /</span><span class="regexp">/ console: weight: 1500 (g)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInKilogram()  /</span><span class="regexp">/ console: weight: 1.5 (kg)</span></span></span></span><br></pre></td></tr></table></figure><h2 id="function-call-and-non-reference-type"><a class="header-anchor" href="#function-call-and-non-reference-type"></a>Function call and non-Reference type</h2><p>看完上述關於 <code>Reference</code> type 的內容後，可以發現提到的都是一般的<a href="#section-this-value-in-function-call-quote-2">函數呼叫情況（… in a usual function call …）</a>。</p><p>那麼是否代表有所謂 <strong>非一般的函數呼叫</strong> 呢？<br>其實就是指在 <a href="#anchor-call-parentheses"><code>call parentheses ( ... )</code></a> 的左側不是 <a href="#reference-type"><code>Reference</code> type</a> 的情況，如下範例所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;)()  <span class="comment">// output_1: ???</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Other complex exmaples</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar()  <span class="comment">// output_2: ???</span></span><br><span class="line">(foo.bar)()  <span class="comment">// output_3: ???</span></span><br><span class="line"></span><br><span class="line">(foo.bar = foo.bar)()  <span class="comment">// output_4: ???</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)()  <span class="comment">// output_5: ???</span></span><br><span class="line">(foo.bar, foo.bar)()  <span class="comment">// output_6: ???</span></span><br></pre></td></tr></table></figure><details><summary><span style="color: green; font-weight: bold">Click me to reveal the answer!</span></summary><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output_1: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line"></span><br><span class="line">output_2: `foo` object</span><br><span class="line">left hand side: `Reference` type</span><br><span class="line"></span><br><span class="line">output_3: `foo` object</span><br><span class="line">left hand side: `Reference` type</span><br><span class="line">Although there is a `grouping operator`* (the parentheses at the both sides of `foo.bar`), it was&apos;t applied.</span><br><span class="line">- steps:</span><br><span class="line">  1. (foo.bar)()</span><br><span class="line">     &lt;-------&gt; Returned value of this expression `(foo.bar)` is `foo.bar`, which is still a `Reference` type</span><br><span class="line">  2. foo.bar()</span><br><span class="line">     &lt;-------&gt; Then, this expression is evaluated</span><br><span class="line"></span><br><span class="line">output_4: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line">Inside the parentheses, there is a expression with `assignment operator` which will return a value**.</span><br><span class="line"></span><br><span class="line">output_5: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line">- steps:</span><br><span class="line">  1. (false || foo.bar)()</span><br><span class="line">     &lt;----------------&gt; Processing this expression (`logical OR`)</span><br><span class="line">  2. (false || foo.bar)</span><br><span class="line">      &lt;---&gt; result of condition is `false`, so that we continue to check the next condition</span><br><span class="line">  3. (false || foo.bar)</span><br><span class="line">               &lt;-----&gt; result of condition is not `false` / `null` / `undefined`, so that returned value will be: `function foo.bar()`</span><br><span class="line">  4. [function foo.bar()]()</span><br><span class="line">     &lt;------------------&gt; this is a `function` object, not a `Reference` type</span><br><span class="line"></span><br><span class="line">output_6: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line">- steps:</span><br><span class="line">  1. (foo.bar, foo.bar)()</span><br><span class="line">     &lt;----------------&gt; Processing this expression (`comma operator`)</span><br><span class="line">  2. (foo.bar, foo.bar)</span><br><span class="line">      &lt;-----&gt; this value is evaluated, but not returned</span><br><span class="line">  3. (foo.bar, foo.bar)</span><br><span class="line">               &lt;-----&gt; this value is evaluated and returned, so that the returned value of this expression is: `function foo.bar()`</span><br><span class="line">  4. [function foo.bar()]()</span><br><span class="line">     &lt;------------------&gt; this is a `function` object, not a `Reference` type</span><br></pre></td></tr></table></figure><p>* <code>grouping operator</code>: which accepts <code>expression</code> only<br>** in a console, entering the following content line by line, you will see the following result:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> a        <span class="comment">// this is a statement</span></span><br><span class="line"><span class="literal">undefined</span>  <span class="comment">// returned value of this statement</span></span><br><span class="line"></span><br><span class="line">&gt; a = <span class="number">1</span>        <span class="comment">// this is an expression</span></span><br><span class="line"><span class="number">1</span>          <span class="comment">// returned value of this expression</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// so that...</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// statement</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">&gt; a = foo            <span class="comment">// expression</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)   // <span class="title">got</span> <span class="title">a</span> <span class="title">returned</span> <span class="title">value</span>: `<span class="title">function</span>` <span class="title">object</span></span></span><br></pre></td></tr></table></figure><ul><li>補充1: <a href="https://2ality.com/2012/09/expressions-vs-statements.html" target="_blank" rel="noopener">expression versus statements in JavaScript</a></li><li>補充2: 關於上方連結中 <code>3.1 Object literal versus block</code> 提到的東西，可以再看看這個應用 <a href="http://www.jsfuck.com/" target="_blank" rel="noopener">JSFuck</a></li></ul></details><h2 id="reference-type-and-null-this-value"><a class="header-anchor" href="#reference-type-and-null-this-value"></a>Reference type and null this value</h2><p>除了上一段所提到的其他種 function call 與其相對應的 <code>this</code> 值，我們還有一些情況需要理解。<br>本段以說明那些 <code>this</code> 應該要被設為 null (也就是說最後會變成 global (node.js) 或 Window (browser)) 的情況：</p><ol><li>Calling an unbound function in a closure:</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// console: global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because:</span></span><br><span class="line"><span class="comment">// var barReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: AO,  // (note*) activated object, which return `this` as null, because `AO.__parent__` is null (or in default value: `global`)</span></span><br><span class="line"><span class="comment">//   propertyName: 'bar'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>* Which might be true only in some implementation of Javascript, e.g. <code>SpiderMonkey</code>, <code>Rhino</code>. See also <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="noopener">this chapter</a></p><ol start="2"><li>In a <code>with</code> statement:</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;,</span><br><span class="line">  x: <span class="number">20</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  foo()  <span class="comment">// console: 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Because:</span></span><br><span class="line"><span class="comment">// var fooReference = &#123;</span></span><br><span class="line"><span class="comment">//  base: __withObject,</span></span><br><span class="line"><span class="comment">//  propertyBane: 'foo'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>這部份需要注意到，此時的 <code>foo</code> 裡面的 <code>this</code> 指向的是一個 <code>__withObject</code> 而非 <code>global</code>，因此印出的 <code>this.x</code> 是 <code>with</code> statement 裡面定義的 <code>x</code> 而非 global scope 中的 <code>x</code>。</p><p>而範例則是在說明使用 <code>with</code> 時會造成的影響，關於 <code>with</code> 的效果，除了原文所述：</p><blockquote><p>The <code>with</code> statement adds its object in front of <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/#affecting-on-scope-chain-during-code-execution" target="_blank" rel="noopener">scope chain</a> i.e. <em>before</em> the activation object. Accordingly, having values of type <code>Reference</code> (by the identifier or a property accessor) we have base object not as an activation object but object of a <code>with</code> statement.</p></blockquote><p>會有這樣的結果是因為在我們使用 <code>with</code> 時，會將 <code>with</code> 裡面定義的物件加到 scope chain 的前面，使得在執行階段時會優先搜尋到 <code>with</code> 內定義的物件，這部分的說明在原文（見下方）和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener">MDN</a> 上也有敘述。</p><blockquote><p>By the way, it relates not only to inner, but also to global functions because the <code>with</code> object <em>shadows</em>* higher object (global or an activation object) of the scope chain</p></blockquote><p>* 因為 <code>with</code> 內的物件會被優先搜索到，導致更上層 scope 中的物件會相對地被 <em>遮蓋掉</em>（對應到原文中的 <code>shadows</code>）</p><ol start="3"><li>In a <code>try ... catch ...</code> statement</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e()  <span class="comment">// console: __catchObject - in ES3, global - fixed in ES5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// on idea (in normal case, implmented in ES3)</span></span><br><span class="line"><span class="comment">// var eReference = &#123;</span></span><br><span class="line"><span class="comment">//  base: __catchObject,</span></span><br><span class="line"><span class="comment">//  propertyName: 'e'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In ES5 (the implementation above is regarded as a bug, so that `this` value is forced to be `global`)</span></span><br><span class="line"><span class="comment">// var eReference = &#123;</span></span><br><span class="line"><span class="comment">//  base: global,</span></span><br><span class="line"><span class="comment">//  propertyName: 'e'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>而關於 <code>catch</code> 在 ES3 和 ES5 中實作的差異，請見下方：</p><ul><li><p><a href="https://www-archive.mozilla.org/js/language/E262-3.pdf" target="_blank" rel="noopener"><code>catch</code> block in ES3 specification</a>:</p><blockquote><p>The production <em>Catch</em>: <code>catch</code> (*Identifier) <em>Block</em> is evaluated as follows:</p><ol><li>Let <em>C</em> be the parameter that has been passed to this production.</li><li>Create a new object as if by the expression <code>new Object()</code>.</li><li>Create a property in the object Result(2). The property’s name is <em>Identifier</em>, value is <em>C</em>.value, and attributes are { DontDelete }.</li><li>Add Result(2) to the front of the scope chain.</li><li>Evaluate <em>Block</em>.</li><li>Remove Result(2) from the front of the scope chain.</li><li>Return Result(5).</li></ol></blockquote><p>我們可以看到在步驟 1~3 中，有一個新物件被建立出來且加上了一個 property 叫作 <em>Identifier</em>，而其值為一開始被傳入 <code>catch</code> 區塊中的參數。<br>而第 4 步是一個關鍵：這時會將步驟 2 建立出的物件放到目前 scope chain 的<strong>前面</strong>。這也是為什麼在上述例子中，ES3 中 <code>eReference</code> 的 base 會是一個 <code>__catchObject</code>。<br>而 <code>catch</code> 區塊的特性：「內部的物件只會存在這個區塊中，當執行流程離開後，便無法再次取得內部的物件」這部份則是透過步驟 6 來達成（移除掉剛剛加到 scope chain 前面的物件）。</p><p>（題外話：看到這邊，其實可以發現在 ES3 spec 內就已經有所謂 <code>block</code> 的用詞。只是這個 <code>block</code> 和 ES6 導入的 <code>block scope</code> 有什麼關聯呢？之後再來研究看看好了）</p></li><li><p><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-12.14" target="_blank" rel="noopener"><code>catch</code> block in ES5 specification</a>:</p><blockquote><p>The production <em>Catch</em>: <code>catch</code> (*Identifier) <em>Block</em> is evaluated as follows:</p><ol><li>Let <em>C</em> be the parameter that has been passed to this production.</li><li>Let <em>oldEnv</em> be the running execution context’s <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener">LexicalEnvironment</a>.</li><li>Let <em>catchEnv</em> be the result of calling <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2.2.2" target="_blank" rel="noopener">NewDeclarativeEnvironment</a> passing <em>oldEnv</em> as the argument.</li><li>Call the <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.2" target="_blank" rel="noopener">CreateMutableBinding</a> concrete method of <em>catchEnv</em> passing the <em>Identifier</em> String value as the argument.</li><li>Call the <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.3" target="_blank" rel="noopener">SetMutableBinding</a> concrete method of <em>catchEnv</em> passing the <em>Identifier</em>, <em>C</em>, and <strong>false</strong> as arguments. Note that the last argument is immaterial in this situation.</li><li>Set the running execution context’s <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener">LexicalEnvironment</a> to <em>catchEnv</em>.</li><li>Let <em>B</em> be the result of evaluating Block.</li><li>Set the running execution context’s <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener">LexicalEnvironment</a> to <em>oldEnv</em>.</li><li>Return <em>B</em>.</li></ol></blockquote><p>在 ES5 中，步驟 1 與 ES3 的作法一樣，但是後續有了一些改變。這邊先簡述為何在 ES5 中，<code>eReference</code> 的 base 會變成 <code>global</code>：<br>因為在步驟 6 中會將目前正在執行的 execution context 的 <code>Lexical environment</code> 設定為 <em>catchEnv</em> （為了 <code>catch</code> 區塊而新建的 <code>Lexical environment</code>） 的 execution context ，所以 <code>catch</code> 區塊可以視為原本的 execution context 的延伸，也因此 <code>eReference</code> 的 base 會指向 <code>global</code>。</p></li></ul><ol start="4"><li>In a recusive function call</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  !bar &amp;&amp; foo(<span class="number">1</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// console:</span></span><br><span class="line"><span class="comment">// global  // the first time</span></span><br><span class="line"><span class="comment">// global  // the second time</span></span><br></pre></td></tr></table></figure><blockquote><p>At the first call of function, base object is the parent activation object (or the global object), at the recursive call — base object should be special object storing the optional name of a function expression.<br>However, in this case <code>this</code> value is also always set to global</p></blockquote><p>若依照一般的執行流程來判斷，第二次印出的結果應該要是一個物件，但是這邊卻會被設定為 <code>global</code> （而這樣才是正確的）。</p><h2 id="this-value-in-function-called-as-the-constructor"><a class="header-anchor" href="#this-value-in-function-called-as-the-constructor"></a>This value in function called as the constructor</h2><p>再來看一個例子，當我們把一個 function 當作物件的 constructor 時：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();  <span class="comment">// console: 1st line: &#123;&#125;; 2nd line: &#123;x: 10&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x);  <span class="comment">// console: 10</span></span><br></pre></td></tr></table></figure><p>關於 <code>new</code> 關鍵字，可見 ES3 specification - 11.2.2：</p><blockquote><p>The production <em>NewExpression</em>: <strong>new</strong> <em>NewExpression</em> is evaluated as follows:</p><ol><li>Evaluate <em>NewExpression</em>.</li><li>Call GetValue(Result(1)).</li><li>If Type(Result(2)) is not Object, throw a <strong>TypeError</strong> exception.</li><li>If Result(2) does not implement the internal <strong>[[Construct]]</strong> method, throw a <strong>TypeError</strong> exception.</li><li>Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).</li><li>Return Result(5).</li></ol></blockquote><p>而關於 <code>this</code> 被綁定到新建立物件的原因在第 4 步驟中呼叫的 <strong>[[Construct]]</strong>，我們把它在 ES3 sepcification 的內容翻出來看：</p><blockquote><p><strong>13.2.2 [[Construct]]</strong><br>When the [[Construct]] property for a Function object <em>F</em> is called, the following steps are taken:</p><ol><li>Create a new native ECMAScript object</li><li>Set the [[Class]] property of Result(1) to <strong>&quot;Object&quot;</strong></li><li>Get the value of the <strong>prototype</strong> property if the F</li><li>If Result(3) is an object, set the [[Prototype]] property of Result(1) to Result(3).</li><li>If Result(3) is not an object, set the [[Prototype]] property of Result(1) to the original Object prototype object as described in section 15.2.3.1.</li><li>Invoke the [[Call]] property of <em>F</em>, providing Result(1) as the <strong>this</strong> value and providing the argument list passed into [[Construct]] as the argument values.</li><li>If Type(Result(6)) is Object then return Result(6).</li><li>Return Result(1).</li></ol></blockquote><p>關鍵就在於上方的步驟 6 ：在呼叫 <em>F</em>.[[call]] 時，會將第 1 步產生的結果（即一個新的 <code>ECMAScript object</code>）設定為 <code>this</code> 的值並將其他傳進這個 <code>[[Construct]]</code> 的參數列表當作呼叫 <em>F</em>.[[Call]] 的參數值。<br>所以如果要用更簡化的方式來解讀這些步驟的話，就如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN 上關於 <code>new</code> 關鍵字的說明</a>：</p><blockquote><ol><li>Creates a blank, plain JavaScript object</li><li>Links (sets the constructor of) this object to another object</li><li>Passes the newly created object from Step 1 as the this context</li><li>Returns <code>this</code> if the function doesn’t return its own object</li></ol></blockquote><p>這也就是為什麼在上述例子中，使用 <code>new</code> 建立一個 <code>a</code> 物件時，會先後分別看到 <code>{}</code> 與 <code>{x: 10}</code>，然後在 <code>console.log(a.x)</code> 時，可以印出 <code>10</code>。</p><h2 id="manual-setting-of-this-value-for-a-function-call"><a class="header-anchor" href="#manual-setting-of-this-value-for-a-function-call"></a>Manual setting of <code>this</code> value for a function call</h2><p>如果要在 call function 時手動設定 <code>this</code> 的話可以使用 <code>apply</code>, <code>call</code> 這兩個方法 (ES5.1 開始支援另一個新的方法 <code>bind</code>，但是並不是用於呼叫函數時的動態綁定，因此這邊暫時不討論)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b)</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="number">20</span>)  <span class="comment">// console: 10, 20  (because `this` === global)</span></span><br><span class="line"></span><br><span class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>)  <span class="comment">// console: 20, 30 (because `this` === &#123;b: 20&#125;)</span></span><br><span class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>])  <span class="comment">// console: 30, 40 (because `this` === &#123;b: 30&#125;)</span></span><br></pre></td></tr></table></figure><p><code>call</code> 與 <code>apply</code> 的第一個參數都是接受一個物件當為綁定的對象，而差別只在於後續的參數給予方式：<br>- <code>call</code> 接受的是一連串的參數，如 <code>a.call(obj, arg1, arg2, ...)</code><br>- <code>apply</code> 接受的是參數陣列，如 <code>a.apply(obj, [arg1, arg2, ...])</code></p><p>參考： <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener"><code>Function.prototype.call</code></a>, <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>Function.prototype.apply</code></a></p><h2 id="conclusion"><a class="header-anchor" href="#conclusion"></a>Conclusion</h2><p><code>this</code> 在 ECMAScript 的底層設計上看起來很複雜，但從我們實作的角度來看，要知道 <code>this</code> 的值其實不會很難。<br>基本上從 <a href="#section-this-value-in-function-call-quote-2">函數的呼叫形式</a> 就可以推算出來，只是要再考慮到其他如 <a href="#function-call-and-non-reference-type">Function call and non-Reference type</a> 和 <a href="#reference-type-and-null-this-value">Reference type and null this value</a> … 等比較特殊的情況而已。</p><p>當然，透過直接探索 ECMAScript specification 也能夠幫助我們更了解 <code>this</code> 的概念，像是：為什麼在我們使用 <code>new</code> 建立新物件時， <code>this</code> 的值會被自動綁定到新物件上。雖然 MDN 也有詳細的說明，但是相信對於希望能更了解根本原因的人，ECMAScript specification 絕對是個很適合的<s>休閒讀物</s>參考書！</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
