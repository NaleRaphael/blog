<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Import a local Python package dynamically by its path</title>
      <link href="/blog/2020/09/11/devlog_import_a_package_dynamically/"/>
      <url>/blog/2020/09/11/devlog_import_a_package_dynamically/</url>
      
        <content type="html"><![CDATA[<p>Dynamically import a module at runtime by its own location is a useful trick when there is something have to run on demand, but which cannot be determined at design time and even it’s not installed in your site-package.</p><p>This is <a href="https://stackoverflow.com/a/67692" target="_blank" rel="noopener">an old question</a> that have been solved in about 12 years ago, and I’ve adopted the solution from that StackOverflow post into my several personal projects.</p><p>But there is an inconspicuous detail took me some time to figure out when I was trying to solve the following problem:</p><blockquote><p>In an application, user can choose to use a module <code>mod_foo</code> which can be the one installed in site-package or the other one which is not installed and exists under a <code>vendor</code> directory.</p></blockquote><h2 id="i-know-that-is-a-module-but-i-can-t-import-it"><a class="header-anchor" href="#i-know-that-is-a-module-but-i-can-t-import-it"></a>I know that is a module, but I can’t import it</h2><p>Let’s take the following project structure as an example, and assume that we are using Python 3.7:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_module/</span><br><span class="line">  __init__.py    # -&gt; including statements like `from .vendor import mod_foo`</span><br><span class="line">  submodule_a.py</span><br><span class="line">  ...</span><br><span class="line">  vendor/</span><br><span class="line">    __init__.py</span><br><span class="line">    mod_foo_repository/</span><br><span class="line">      mod_foo/</span><br><span class="line">        __init__.py     # -&gt; including statements like `from mod_foo.core import *`</span><br><span class="line">        core.py</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>In order to make other submodules in <code>my_module</code> able to use <code>mod_foo</code> without considering which one to import (the one in site-package or the other one locates in <code>vendor</code> directory), we can handle this problem in <code>vendor/__init__.py</code>. That is, <code>mod_foo</code> will be exposed as a submodule under <code>my_module.vendor</code>, and we can just write the following statement to use <code>mod_foo</code> in <code>__init__.py</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: my_module/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .vendor <span class="keyword">import</span> mod_foo</span><br></pre></td></tr></table></figure><p><a name="anchor_snippet_load_module"></a><br>With the solution provided in <a href="https://stackoverflow.com/a/67692" target="_blank" rel="noopener">this post</a>, content of <code>vendor/__init__.py</code> would be:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: `my_module/vendor/__init__.py`</span></span><br><span class="line">USE_LOCAL_MOD = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> USE_LOCAL_MOD:</span><br><span class="line">    <span class="comment"># Import from local directory</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_local_mod</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">        <span class="keyword">import</span> importlib.util</span><br><span class="line"></span><br><span class="line">        this_dir = Path(__file__).parent</span><br><span class="line">        dir_mod = Path(this_dir, <span class="string">"mod_foo_repository"</span>, <span class="string">"mod_foo"</span>)</span><br><span class="line">        fn = Path(dir_mod, <span class="string">"__init__.py"</span>)</span><br><span class="line"></span><br><span class="line">        spec = importlib.util.spec_from_file_location(<span class="string">"mod_foo"</span>, fn)</span><br><span class="line">        mod = importlib.util.module_from_spec(spec)</span><br><span class="line"></span><br><span class="line">        spec.loader.exec_module(mod)</span><br><span class="line">        <span class="keyword">return</span> mod</span><br><span class="line"></span><br><span class="line">    mod_foo = load_local_mod()    <span class="comment"># expose loaded module with name `mod_foo`</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Import from site-package</span></span><br><span class="line">    <span class="keyword">import</span> mod_foo</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'mod_foo'</span>]</span><br></pre></td></tr></table></figure><p><a name="anchor_traceback"></a><br>However, we will get this error when we try import <code>my_module</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from my_module.vendor.mod_foo import foo</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;...\my_module\__init__.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from . import vendor</span><br><span class="line">  File &quot;...\my_module\vendor\__init__.py&quot;, line 19, in &lt;module&gt;</span><br><span class="line">    imgui = load_pyimgui()</span><br><span class="line">  File &quot;...\my_module\vendor\__init__.py&quot;, line 16, in load_local_mod</span><br><span class="line">    spec.loader.exec_module(mod)</span><br><span class="line">  File &quot;...\my_module\vendor\mod_foo_repository\mod_foo\__init__.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    from mod_foo.core import *</span><br><span class="line">ModuleNotFoundError: No module named &apos;mod_foo&apos;</span><br></pre></td></tr></table></figure><h2 id="why-it-failed"><a class="header-anchor" href="#why-it-failed"></a>Why it failed?</h2><p>It seems like a common error when we are trying to import a module which doesn’t exist or things related to namespace management are messed up in <code>__init__.py</code>. But since we’ve known that <code>mod_foo</code> does exist, what does this error actually indicate?</p><p>From the error message shown above, we found that the module cannot be found is <code>mod_foo</code> itself rather than any submodule in it. So that we can confirm this error isn’t resulted by incorrect namespace management in <code>mod_foo.__init__.py</code>. It’s more likely an error occured when the import system is finding <code>mod_foo</code>.</p><p>Luckily, there is an function <a href="https://docs.python.org/3/library/functions.html#__import__" target="_blank" rel="noopener"><code>importlib.__import__()</code></a> which can be used as a alternative to the import statement we usually use, as stated in its documentation. And the reason why we are going to use this function to trace this kind of error is that it will provide more detailed traceback when it failed to import a module.</p><p>Equivalent invocation would be:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">my_module = importlib.__import__(<span class="string">'my_module'</span>)</span><br></pre></td></tr></table></figure><p>And we will get the following traceback:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1086, in __import__</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 1006, in _gcd_import</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 983, in _find_and_load</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 967, in _find_and_load_unlocked</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 677, in _load_unlocked</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 728, in exec_module</span><br><span class="line">  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 219, in _call_with_frames_removed</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;...\my_module\__init__.py&quot;, line 2, in &lt;module&gt;</span><br><span class="line">    from . import vendor</span><br><span class="line">  File &quot;...\my_module\vendor\__init__.py&quot;, line 19, in &lt;module&gt;</span><br><span class="line">    imgui = load_pyimgui()</span><br><span class="line">  File &quot;...\my_module\vendor\__init__.py&quot;, line 16, in load_local_mod</span><br><span class="line">    spec.loader.exec_module(mod)</span><br><span class="line">  File &quot;...\my_module\vendor\mod_foo_repository\mod_foo\__init__.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    from mod_foo.core import *</span><br><span class="line">ModuleNotFoundError: No module named &apos;mod_foo&apos;</span><br></pre></td></tr></table></figure><p>Since <code>__import__()</code> is a function comes from a fronzen module, we cannot insert breakpoints by <code>pdb</code> to trace it. But it’s enough for us to understand what happened underneath the execution of a import statement.</p><p>Before starting backtracing, we can try to find out where the error message comes from. Since there is only <code>importlib</code> included in this traceback, it would be a relatively easy task to find it. Let’s see how to do this:</p><ol><li><p>As we can speculate there is a constant string <code>&quot;No module named&quot;</code> in the <code>importlib/_bootstrap.py</code>, we find that it’s declared with a variable name <code>_ERR_MSG_PREFIX</code> in this file.</p></li><li><p>Then we can find that there is another prepared string formatter <code>_ERR_MSG</code> locateing right after <code>_ERR_MSG_PREFIX</code>, and which is formed with <code>_ERR_MSG_PREFIX + '{!r}'</code>. And it’s actually the format of error message we got in the traceback. So that we can keep going to find out where <code>_ERR_MSG</code> is used.</p></li><li><p>In function <code>_find_and_load_unlocked()</code>, we find the following lines:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_and_load_unlocked</span><span class="params">(name, import_)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">if</span> spec <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ModuleNotFoundError(_ERR_MSG.format(name), name=name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        module = _load_unlocked(spec)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>With this clue, we can speculate that here is the location where the error raised.</p><p>However, note that we cannot actually get the detail of error simply from this traceback if a module is imported by the built-in <code>import</code> statement. And this is why you can see the last few lines of traceback message are not generated from <code>importlib._bootstrap</code> module. Despite of this limitation, we can still understand the possible cause from the other part of function calls.</p></li></ol><p>Let’s keep going on checking out the call stack, those function calls in <code>&lt;frozen importlib._bootstrap&gt;</code> are invoked because we are using <code>importlib.__import__()</code>. And remember where <code>ModuleNotFoundError</code> is raised? It comes from <code>_find_and_load_unlocked()</code> and this function call exists in this traceback. So it’s worthy to have a further investigation, let’s see how it’s implemented:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_and_load_unlocked</span><span class="params">(name, import_)</span>:</span></span><br><span class="line">    path = <span class="literal">None</span></span><br><span class="line">    parent = name.rpartition(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> parent:</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">not</span> <span class="keyword">in</span> sys.modules:</span><br><span class="line">            _call_with_frames_removed(import_, parent)</span><br><span class="line">        <span class="comment"># Crazy side-effects!</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> sys.modules:</span><br><span class="line">            <span class="keyword">return</span> sys.modules[name]</span><br><span class="line">        parent_module = sys.modules[parent]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            path = parent_module.__path__</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            msg = (_ERR_MSG + <span class="string">'; &#123;!r&#125; is not a package'</span>).format(name, parent)</span><br><span class="line">            <span class="keyword">raise</span> ModuleNotFoundError(msg, name=name) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ----- This is the part we've just checked -----</span></span><br><span class="line">    spec = _find_spec(name, path)</span><br><span class="line">    <span class="keyword">if</span> spec <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ModuleNotFoundError(_ERR_MSG.format(name), name=name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        module = _load_unlocked(spec)</span><br><span class="line">    <span class="comment"># -----------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> parent:</span><br><span class="line">        <span class="comment"># Set the module as an attribute on its parent.</span></span><br><span class="line">        parent_module = sys.modules[parent]</span><br><span class="line">        setattr(parent_module, name.rpartition(<span class="string">'.'</span>)[<span class="number">2</span>], module)</span><br><span class="line">    <span class="keyword">return</span> module</span><br></pre></td></tr></table></figure><p>According to the last call in traceback shown as below, the module failed to be imported is <code>mod_foo</code> and it has no parent package. So the part of <code>if parent: ...</code> will be skipped and it continues executing <code>spec = _find_spec(name, path)</code>. And the expected returned value <code>spec</code> should be <code>None</code>, so that it can correspond to the error we got.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File &quot;...\my_module\vendor\mod_foo_repository\mod_foo\__init__.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    from mod_foo.core import *</span><br><span class="line">ModuleNotFoundError: No module named &apos;mod_foo&apos;</span><br></pre></td></tr></table></figure><p>Therefore, we should take a look at <code>_find_spec()</code> and figure out why it returns <code>None</code>. Let’s simplify it into the code below:<br><a name="anchor_snippet_importlib_find_spec"></a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_spec</span><span class="params">(name, path, target=None)</span>:</span></span><br><span class="line">    meta_path = sys.meta_path</span><br><span class="line">    <span class="keyword">if</span> meta_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> ImportError(<span class="string">"sys.meta_path is None, Python is likely "</span></span><br><span class="line">                          <span class="string">"shutting down"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> meta_path:</span><br><span class="line">        _warnings.warn(<span class="string">'sys.meta_path is empty'</span>, ImportWarning)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># We check sys.modules here for the reload case.  While a passed-in</span></span><br><span class="line">    <span class="comment"># target will usually indicate a reload there is no guarantee, whereas</span></span><br><span class="line">    <span class="comment"># sys.modules provides one.</span></span><br><span class="line">    is_reload = name <span class="keyword">in</span> sys.modules</span><br><span class="line">    <span class="keyword">for</span> finder <span class="keyword">in</span> meta_path:</span><br><span class="line">        <span class="comment"># ... stuff for searching spec, and return spec if it's found ...</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>Now we know that returned value will be <code>None</code> only when it failed to find a spec in the loop <code>for finder in meta_path: ...</code>. And what is <code>meta_path</code>? As it’s shown in the code, it’s a <a href="https://docs.python.org/3/library/sys.html#sys.meta_path" target="_blank" rel="noopener"><code>sys.meta_path</code></a> which contains path finder objects for finding module from different types of source. We can even just print it out to understand a bit more, and here is it:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;class &apos;_frozen_importlib.BuiltinImporter&apos;&gt;, &lt;class &apos;_frozen_importlib.FrozenImporter&apos;&gt;, &lt;class &apos;_frozen_importlib_external.PathFinder&apos;&gt;]</span><br></pre></td></tr></table></figure><p>Thanks for these well-named classes, it’s easy to figure out what they are responsible for individually. Literally, we can speculate that:</p><ul><li><code>BuiltinImporter</code>: a importer for built-in modules</li><li><code>FrozenImporter</code>: a importer for frozen modules</li><li><code>PathFinder</code>: according to the docstring of it in <code>_bootstrap_external.py</code>, it’s a meta path finder for <code>sys.path</code> and package <code>__path__</code> attributes</li></ul><p>What we are interested in is <code>PathFinder</code> because we are solving an issue resulted by importing a normal module. And <code>sys.path</code> is also more suspectful than <code>__path__</code> attributes to be investigated further now.</p><p><a name="anchor_cause_assumption"></a><br>As we’ve known that <code>sys.path</code> is a list containing paths of package including those ones from site-package and so on, the problem is obviously resulted by the absence name <code>mod_foo</code> in <code>sys.path</code>. In other words, this <code>ModuleNotFoundError</code> is raised because it failed to find <code>mod_foo</code> in <code>sys.path</code> even we had imported it manually by <code>importlib.util</code>.</p><h2 id="let-s-try-to-solve-it"><a class="header-anchor" href="#let-s-try-to-solve-it"></a>Let’s try to solve it</h2><p>Now we have figured out the cause of this error. But how can we solve it?</p><p>Let’s recall <a href="#anchor_snippet_load_module">what have been done when we are trying to load <code>mod_foo</code></a>:</p><ul><li>Location of module is found and existing</li><li><code>mod_foo</code> is loaded (<code>spec.loader.exec_module(mod)</code>)</li><li><code>mod_foo</code> is stored into a varaible with same name and exposed in <code>vendor.__init__.py</code></li></ul><p>Till now, it seems we didn’t miss things for loading this module. So let’s go back to <a href="#anchor_traceback">the location</a> where this error is caught and insert a breakpoint before executing the line.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in mod_foo.__init__.py</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">import</span> pdb; pdb.set_trace()     <span class="comment"># &lt;- add this</span></span><br><span class="line"><span class="keyword">from</span> mod_foo.core <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>As we re-run the command for importing <code>my_module</code>, program will stop at the line where the breakpoint is set. And remember the <a href="#anchor_cause_assumption">cause</a> assumed in previous section? Now we can check whether path of <code>mod_foo</code> exisits in <code>sys.path</code> by the following commands:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(pdb) <span class="keyword">import</span> sys;</span><br><span class="line">(pdb) <span class="keyword">for</span> v <span class="keyword">in</span> sys.path: print(v)</span><br><span class="line"><span class="comment"># ... lots of path will be printed here ...</span></span><br></pre></td></tr></table></figure><p>Bingo, path of <code>mod_foo</code> is actually absence in <code>sys.path</code>. Therefore, we can try to insert that path into <code>sys.path</code> and check whether it would work.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># continue from previous session</span></span><br><span class="line">(pdb) <span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line">(pdb) sys.path.insert(<span class="number">0</span>, osp.dirname(__file__))</span><br><span class="line"></span><br><span class="line"><span class="comment"># try to import `mod_foo`</span></span><br><span class="line">(pdb) <span class="keyword">import</span> mod_foo    <span class="comment"># -&gt; import successfully</span></span><br></pre></td></tr></table></figure><p>Great! It actually works. But since it’s usually not recommended to manipulate <code>sys.path</code> directly even though it would be reset after re-runing your program, we have to implement another better solution.</p><h2 id="a-better-solution"><a class="header-anchor" href="#a-better-solution"></a>A better solution</h2><p>Remember that we’ve already load <code>mod_foo</code> successfully in the function <code>load_local_mod()</code>? We can just modify it slightly to make all these thing work.</p><p>Recall the implementation of <a href="#anchor_snippet_importlib_find_spec"><code>_find_spec()</code></a>, there is a line of code <code>is_reload = name in sys.modules</code>. As it’s stated in the comment above it, we can try to register <code>mod_foo</code> into <code>sys.modules</code> and make it marked as a module going to be reloaded.</p><p>To do this, we can simply modify our implementation to this one:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># file: `my_module/vendor/__init__.py`</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">USE_LOCAL_MOD = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> USE_LOCAL_MOD:</span><br><span class="line">    <span class="comment"># Import from local directory</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_local_mod</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">        <span class="keyword">import</span> importlib.util</span><br><span class="line"></span><br><span class="line">        this_dir = Path(__file__).parent</span><br><span class="line">        dir_mod = Path(this_dir, <span class="string">"mod_foo_repository"</span>, <span class="string">"mod_foo"</span>)</span><br><span class="line">        fn = Path(dir_mod, <span class="string">"__init__.py"</span>)</span><br><span class="line"></span><br><span class="line">        spec = importlib.util.spec_from_file_location(<span class="string">"mod_foo"</span>, fn)</span><br><span class="line">        mod = importlib.util.module_from_spec(spec)</span><br><span class="line"></span><br><span class="line">        sys.modules[<span class="string">'mod_foo'</span>] = mod    <span class="comment">#  &lt;- (1) register `mod_foo`</span></span><br><span class="line">        spec.loader.exec_module(mod)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># (2) register `mod_foo` with a name prefixed with our module</span></span><br><span class="line">        module_name = <span class="string">'my_module.vendor.imgui'</span></span><br><span class="line">        sys.modules[module_name] = mod</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mod</span><br><span class="line"></span><br><span class="line">    mod_foo = load_local_mod()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Import from site-package</span></span><br><span class="line">    <span class="keyword">import</span> mod_foo</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'mod_foo'</span>]</span><br></pre></td></tr></table></figure><p>In the snippet above:</p><ol><li>That’s how we register a module into <code>sys.modules</code></li><li>Without this, import statements in our submodule will fail when we are trying to perform a relative import, e.g. <code>from .vendor import mod_foo</code>. And we will get this error: <code>ModuleNotFoundError: No module named 'my_module.vendor.mod_foo'</code></li></ol><h2 id="ta-da-you-may-also-want-to-know-this"><a class="header-anchor" href="#ta-da-you-may-also-want-to-know-this"></a>Ta-da! You may also want to know this</h2><p>Without performing the second module registration <code>sys.modules[module_name] = mod</code>, you might run into this hidden issue:</p><blockquote><p>If there is a <code>mod_foo</code> already installed in your site-package, this local import will be sucessful. But <code>mod_foo.core</code> <strong>is actually the one installed in your site-package</strong> rather than this local one.</p></blockquote><h2 id="finally"><a class="header-anchor" href="#finally"></a>Finally</h2><p>As always, here is <a href="https://github.com/NaleRaphael/codememo/blob/6ae07b5/codememo/vendor/__init__.py#L27-L93" target="_blank" rel="noopener">a file</a> for those things we’ve talked here. Hope this can help you understand it more quickly.</p><p>Besides, I found that there is <strong>ALREADY</strong> <a href="https://stackoverflow.com/a/50395128" target="_blank" rel="noopener">an answer posted under that StackOverflow post</a>.</p><style>.centered-img {    margin: auto;    display: block;}</style><img class="centered-img" src="https://i.kym-cdn.com/entries/icons/mobile/000/027/475/Screen_Shot_2018-10-25_at_11.02.15_AM.jpg" alt="meme_surprise_pikachu" width="320"> <p>But still hope you enjoy this article!</p>]]></content>
      
      
      
        <tags>
            
            <tag> devlog </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Things behind `sys.settrace()`</title>
      <link href="/blog/2020/03/12/devlog_things_behind_sys_settrace/"/>
      <url>/blog/2020/03/12/devlog_things_behind_sys_settrace/</url>
      
        <content type="html"><![CDATA[<p>As I was digging into CPython’s internals in order to implement a new feature of a virtual machine made recently, I guess that I probably solved a <a href="https://github.com/nedbat/byterun/blob/62f9b1a9c85f52c28b78cc8942243c5c962b1954/byterun/pyvm2.py#L325-L327" target="_blank" rel="noopener">TODO task listed in the source code of <code>byterun</code></a> to a certain degree.</p><p>This story begins with an interesting idea of using <code>pdb</code> in <code>bytefall</code> virtual machine…</p><p>(To avoid confusion and being affected by the changes among versions, here we take CPython 3.7 as the runtime)</p><h2 id="when-you-call-pdb-set-trace"><a class="header-anchor" href="#when-you-call-pdb-set-trace"></a>When you call <code>pdb.set_trace()</code></h2><p>Typically, you need the following line to enter the debugging mode provided by <code>pdb</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure><p>Once that line is executed, you are able to use all commands provide by <code>pdb</code> or have a good time with REPL inside the interactive mode. However, in prior versions of <code>bytefall</code>, internal execution flow of <code>bytefall</code> virtual machine will be revealed when debugging mode is activated.</p><p>It’s such a tsunami for users who just want to check how their code work. Because they will not only be overwhelmed by too much information, but also get stucked in those frames with data related to their code indirectly.</p><p>So, our goal is to make user able to use <code>pdb</code> like the way they are using in a normal Python runtime. To achieve this goal, we have to understand how <code>pdb.set_trace()</code> work first. But before diving into source code, we need to figure out what we are interesting in, and it will help us focus on the problem we want to solve.</p><p><a name="goal_of_tracing_pdb_source"></a></p><p>As we want to control the information exposure of internal execution, what we need to trace are most likely some operations related to <code>frame</code>. Because <code>frame</code> contains information of executing scope, and it also related to the call stack which we can get from <code>traceback</code>.</p><p>It sounds like a reasonable guess, so let’s start to take a quick look at the implementation of <code>pdb</code>.</p><ol><li><p>Starting from the call <code>pdb.set_trace()</code>, we can speculate that <code>set_trace</code> is a function defined in the module scope of <code>pdb</code>. And here is what we got in <code>pdb.py</code>:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @pdb.py::set_trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_trace</span><span class="params">(*, header=None)</span>:</span></span><br><span class="line">    pdb = Pdb()</span><br><span class="line">    <span class="keyword">if</span> header <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Print `header` to stdout</span></span><br><span class="line">        pdb.message(header)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The code we want to know</span></span><br><span class="line">    pdb.set_trace(sys._getframe().f_back)</span><br></pre></td></tr></table></figure><p>In those lines above, we know that there is an instance of <code>Pdb</code> class being instantiated and its method <code>set_trace()</code> is called.<br>Also, <code>set_trace()</code> is the only operation related to frame here, so that it’s what we are interesting in. However, we cannot find <code>set_trace()</code> in <code>Pdb</code> class, so it’s probably defined in its parent <code>bdb.Bdb</code>.</p></li><li><p>After navigating to the file <code>bdb.py</code>, we found it indeed:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># @bdb.py::class Bdb::set_trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_trace</span><span class="params">(self, frame=None)</span>:</span></span><br><span class="line">    <span class="string">"""Start debugging from frame.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If frame is not specified, debugging starts from caller's frame.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        frame = sys._getframe().f_back</span><br><span class="line">    self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Install callback `trace_dispatch` to each frame, and set `botframe` up</span></span><br><span class="line">    <span class="keyword">while</span> frame:</span><br><span class="line">        frame.f_trace = self.trace_dispatch</span><br><span class="line">        self.botframe = frame</span><br><span class="line">        frame = frame.f_back</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set information for `step` command</span></span><br><span class="line">    self.set_step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The code we want to know</span></span><br><span class="line">    sys.settrace(self.trace_dispatch)</span><br></pre></td></tr></table></figure><p>According to the documentation of <a href="https://docs.python.org/3/library/inspect.html#types-and-members" target="_blank" rel="noopener">inspect</a> and <a href="https://docs.python.org/3/library/sys.html#sys.settrace" target="_blank" rel="noopener">sys</a>, we can know that <code>f_trace</code> is used to store a callback function for tracing code, and that callback function will be installed through <code>sys.settrace()</code>.</p><p>And what will the callback function <code>trace_dispatch()</code> do?</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace_dispatch</span><span class="params">(self, frame, event, arg)</span>:</span></span><br><span class="line">    <span class="comment"># Details about this callback function is also documented in its</span></span><br><span class="line">    <span class="comment"># docstring.</span></span><br><span class="line">    <span class="keyword">if</span> self.quitting:</span><br><span class="line">        <span class="keyword">return</span> <span class="comment"># None</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'line'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_line(frame)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_call(frame, arg)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'return'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_return(frame, arg)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'exception'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_exception(frame, arg)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'c_call'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.trace_dispatch</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'c_exception'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.trace_dispatch</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'c_return'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.trace_dispatch</span><br><span class="line">    print(<span class="string">'bdb.Bdb.dispatch: unknown debugging event:'</span>, repr(event))</span><br><span class="line">    <span class="keyword">return</span> self.trace_dispatch</span><br></pre></td></tr></table></figure><p>It works like the way how it’s described in document. When it’s invoked with argument <code>event</code> of <code>'line', 'call', 'return', 'exception'</code>, it will call those functions corresponding to each event. But it’s irrelevant to the control of frame stack. In other word, it’s like a subscriber who is responsible to do something according to given <code>frame</code>, not an issuer which is able to determine when to fire an event with specific <code>frame</code>. Therefore, it seems <code>trace_dispatch()</code> is not a function able to control the information exposure of internal execution.</p><p>But it’s fine, let’s keep tracing deeper into <code>sys.settrace()</code>.</p></li><li><p>Since <code>sys</code> module is not written in Python, we have to access it from CPython source code. And here is how <code>sys.settrace()</code> looks like:</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/sysmodule.c::sys_settrace</span></span><br><span class="line"><span class="comment">// signature in Python:</span></span><br><span class="line"><span class="comment">//   `settrace(function)`</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">sys_settrace(PyObject *self, PyObject *args) &#123;</span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == Py_None)</span><br><span class="line">        PyEval_SetTrace(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// args: your Python callback function</span></span><br><span class="line">        PyEval_SetTrace(trace_trampoline, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>According to the signature of <code>sys.settrace()</code>, we can know that <code>args</code> is the callback function passed from Python side. And once <code>args</code> is not <code>None</code>, <code>PyEval_SetTrace()</code> will be called with a function named <code>trace_trampoline()</code> and the callback function we just passed in.</p><p>Next, let’s see how <code>trace_trampoline()</code> is implemented.</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/sysmodule.c::trace_trampoline</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">trace_trampoline(PyObject *self, PyFrameObject *frame,</span><br><span class="line">                 <span class="keyword">int</span> what, PyObject *arg) &#123;</span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine the callback function</span></span><br><span class="line">    <span class="keyword">if</span> (what == PyTrace_CALL)</span><br><span class="line">        callback = self;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        callback = frame-&gt;f_trace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    result = call_trampoline(callback, frame, what, arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @cpython/Python/sysmodule.c::call_trampoline</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">call_trampoline(PyObject* callback,</span><br><span class="line">                PyFrameObject *frame, <span class="keyword">int</span> what, PyObject *arg) &#123;</span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">0</span>] = (PyObject *)frame;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">1</span>] = whatstrings[what];</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">2</span>] = (arg != <span class="literal">NULL</span>) ? arg : Py_None;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call the Python-level function */</span></span><br><span class="line">    result = _PyObject_FastCall(callback, <span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remember what the signature of <code>trace_dispatch()</code> looks like? The last 3 arguments are the same as those in signatures of <code>trace_trampoline()</code> and <code>call_trampoline()</code>.<br>So, based on these implementation and function signatures, we can speculate that <code>trace_trampoline()</code> would play a role of invoking callback function while it is triggered.</p><p>But still, these 2 C-functions are not used to control frame stack. There is one remaining function for us to keep investigating: <code>PyEval_SetTrace()</code>.</p></li><li><p>Prefix of <code>PyEval_SetTrace()</code> indicating that this function is related to the bytecode dispatching loop locating in <code>ceval.c</code>, and here is a sketch of it:</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c::PyEval_SetTrace</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyEval_SetTrace(Py_tracefunc func, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    tstate-&gt;c_tracefunc = func;</span><br><span class="line">    tstate-&gt;c_traceobj = arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can see that there are 2 attributes of <code>tstate</code> is set, and they are also the input arguments of this function. To make it clear, let’s recall the call stack starting from <code>sys.settrace()</code> in Python with a custom callback function named in <code>py_callback</code>:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># --- In Python ---</span><br><span class="line">sys.settrace(py_callback)</span><br><span class="line"></span><br><span class="line"># --- In aspect of C ---</span><br><span class="line"># -&gt;</span><br><span class="line"># signature: `sys_settrace(PyObject *self, PyObject *args)`</span><br><span class="line">sys_settrace(..., py_callback)</span><br><span class="line"></span><br><span class="line"># -&gt;</span><br><span class="line"># signature: `PyEval_SetTrace(Py_tracefunc func, PyObject *arg)`</span><br><span class="line">PyEval_SetTrace(trace_trampoline, py_callback)</span><br></pre></td></tr></table></figure><p>Therefore, we can know that <code>func</code> and <code>arg</code> are actually:</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in PyEval_SetTrace()</span></span><br><span class="line">tstate-&gt;c_tracefunc = func;     <span class="comment">// trace_trampoline</span></span><br><span class="line">tstate-&gt;c_traceobj = arg;       <span class="comment">// py_callback</span></span><br></pre></td></tr></table></figure><p>And we can be sure that <code>pdb.set_trace()</code> is just an operation of setting up things for tracing code, instead of an operation related to the control of frame stack. But since we got some clues about <code>tstate-&gt;c_tracefunc</code> and <code>tstate-&gt;c_traceobj</code>, we can still go further into the huge loop inside <code>_PyEval_EvalFrameDefault()</code>.</p></li></ol><h2 id="take-a-look-at-the-huge-evaluation-loop"><a class="header-anchor" href="#take-a-look-at-the-huge-evaluation-loop"></a>Take a look at the huge evaluation loop</h2><p>Before analyzing <code>_PyEval_EvalFrameDefault()</code>, we can find out those functions which take either <code>tstate-&gt;c_tracefunc</code> or <code>tstate-&gt;c_traceobj</code> as its arguments. This could make us focus on those parts which we are interested in.</p><p>And here are the signatures of those functions we found:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">call_trace_protected(Py_tracefunc func, PyObject *obj,</span><br><span class="line">                     PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">                     <span class="keyword">int</span> what, PyObject *arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">call_trace(Py_tracefunc func, PyObject *obj,</span><br><span class="line">           PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">           <span class="keyword">int</span> what, PyObject *arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">maybe_call_line_trace(Py_tracefunc func, PyObject *obj,</span><br><span class="line">                      PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">                      <span class="keyword">int</span> *instr_lb, <span class="keyword">int</span> *instr_ub, <span class="keyword">int</span> *instr_prev)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">call_exc_trace(Py_tracefunc func, PyObject *self,</span><br><span class="line">               PyThreadState *tstate, PyFrameObject *f)</span><br></pre></td></tr></table></figure><p>Bases on this, we can simplify the implementation of <code>_PyEval_EvalFrameDefault()</code> to the following one:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c::_PyEval_EvalFrameDefault</span></span><br><span class="line">_PyEval_EvalFrameDefault() &#123;</span><br><span class="line">    <span class="comment">/* 0. Definition of marcos */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. Push a new frame to stack, as entering a new code block. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. Invoke trace function with event: PyTrace_CALL  */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    call_trace_protected(..., PyTrace_CALL, ...)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. Loop for bytecode dispatch */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* 4. Invoke trace function with event: PyTrace_LINE */</span></span><br><span class="line">    fast_next_opcode:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        maybe_call_line_trace(..., PyTrace_LINE, ...)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. Dispatch opcode */</span></span><br><span class="line">    dispatch_opcode:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. Handle errors and invoke trace function with event: PyTrace_EXCEPTION */</span></span><br><span class="line">error:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        call_exc_trace(...)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. Handle the end of block, unwind remaining blocks */</span></span><br><span class="line">fast_block_end:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8. Invoke trace function with event: PyTrace_RETURN */</span></span><br><span class="line">fast_yield:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    call_trace(..., PyTrace_RETURN, ...)  <span class="comment">// or `call_trace_protected()`</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 9. Pop frame from stack, as exiting a code block */</span></span><br><span class="line">exit_eval_frame:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With the simplified code above, we can roughly understand the execution flow of a CPython interpreter. Besides, timing of each trace event documented in <code>trace_dispatch()</code> is also found out now (those sections are marked at the code block above):</p><ul><li>‘call’: section_02, PyTrace_CALL</li><li>‘line’: section_03, PyTrace_LINE</li><li>‘exception’: section_06, PyTrace_EXCEPTION</li><li>‘return’: section_08, PyTrace_RETURN</li></ul><p>Therefore, answer of <a href="#goal_of_tracing_pdb_source">our guess mentioned in previous section</a> is revealed:</p><ol><li>Frame stack is not controlled by a single function, it related to the recursive execution of <code>_PyEval_EvalFrameDefault()</code>. (further reading: <a href="https://github.com/python/cpython/blob/39680fb7043e555469e08d3c4f49073acca77b20/Objects/call.c#L385-L440" target="_blank" rel="noopener">cpython/Objects/call.c</a>)</li><li>There is nothing like an event issuer, tracing events are issued after entering those execution blocks.</li></ol><h2 id="so-how-would-pdb-work-with-line-tracing"><a class="header-anchor" href="#so-how-would-pdb-work-with-line-tracing"></a>So, how would <code>pdb</code> work with line tracing</h2><p>There is an interesting function named <code>maybe_call_line_trace()</code>, and you can see that it will be invoked whenever there is a new <code>opcode</code> is going to be dispatched (see also <a href="https://github.com/python/cpython/blob/39680fb7043e555469e08d3c4f49073acca77b20/Python/ceval.c#L1022-L1025" target="_blank" rel="noopener">here</a>).</p><p>But we should note that there is a prefix <code>maybe</code>, which indicates that function actually won’t invoke a trace function everytime when it is executed. It does make sense, because what is going to be dispatched here is <strong>bytecode</strong>, rather than <strong>source code</strong> we written. And one line of source code usually can be compiled to multiple lines of bytecode.</p><p>Now, another question comes up: “How does it knows when to invoke trace function for line tracing since <code>maybe_call_line_trace()</code> locates inside a loop for dispatching bytecode?”<br>It’s not a hard problem to be answered after checking out how it is implemented:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c::maybe_call_line_trace</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">maybe_call_line_trace(Py_tracefunc func, PyObject *obj,</span><br><span class="line">                      PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">                      <span class="keyword">int</span> *instr_lb, <span class="keyword">int</span> *instr_ub, <span class="keyword">int</span> *instr_prev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> line = frame-&gt;f_lineno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the last instruction executed isn't in the current</span></span><br><span class="line"><span class="comment">       instruction window, reset the window.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;f_lasti &lt; *instr_lb || frame-&gt;f_lasti &gt;= *instr_ub) &#123;</span><br><span class="line">        PyAddrPair bounds;</span><br><span class="line">        line = _PyCode_CheckLineNumber(frame-&gt;f_code, frame-&gt;f_lasti,</span><br><span class="line">                                       &amp;bounds);</span><br><span class="line">        *instr_lb = bounds.ap_lower;</span><br><span class="line">        *instr_ub = bounds.ap_upper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If the last instruction falls at the start of a line or if it</span></span><br><span class="line"><span class="comment">       represents a jump backwards, update the frame's line number and</span></span><br><span class="line"><span class="comment">       then call the trace function if we're tracing source lines.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((frame-&gt;f_lasti == *instr_lb || frame-&gt;f_lasti &lt; *instr_prev)) &#123;</span><br><span class="line">        frame-&gt;f_lineno = line;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;f_trace_lines) &#123;</span><br><span class="line">            result = call_trace(func, obj, tstate, frame, PyTrace_LINE, Py_None);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Always emit an opcode event if we're tracing all opcodes. */</span></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;f_trace_opcodes) &#123;</span><br><span class="line">        result = call_trace(func, obj, tstate, frame, PyTrace_OPCODE, Py_None);</span><br><span class="line">    &#125;</span><br><span class="line">    *instr_prev = frame-&gt;f_lasti;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clearly, we can know that:</p><ol><li>There is a function <code>_PyCode_CheckLineNumber()</code> which is used to find the upper and lower bound of index of bytecode instruction (denoted as <code>instr_lb</code> and <code>instr_ub</code>; further reading: <a href="https://github.com/python/cpython/blob/3.7/Objects/lnotab_notes.txt" target="_blank" rel="noopener">line number table</a>).</li><li><code>frame.f_lasti</code> is an index of the lastest executed bytecode instruction.</li><li>Just like the comment shown above: once we are just entering a new interval of bytecode instructions (<code>frame-&gt;f_lasti == *instr_lb</code>) or an operation of jumping backward has been executed (e.g. block of <code>for</code>/<code>while</code> loop), trace function will be invoked (of course, only when the flag <code>frame-&gt;f_trace_lines</code> is set).</li><li>If the flag <code>frame-&gt;f_trace_opcodes</code> is set, trace function will be invoked with an event argument <code>PyTrace_OPCODE</code>.</li></ol><p>Besides, we got a useful information from it:</p><blockquote><p>Line number of source code is evaluated only when it need to be used.</p></blockquote><p>Though that is not a topic of this article, it shows itself as a part of the reason why a Python script runs slower under a line tracing mode or profiling mode.</p><h2 id="in-bytefall"><a class="header-anchor" href="#in-bytefall"></a>In <code>bytefall</code>…</h2><p>Figuring out how the mechanism of line tracing works in CPython not only helps me to complete <a href="https://github.com/NaleRaphael/bytefall/blob/ee207a1e9e9fc40cd54f9ccac1e1cb61b12c27dc/bytefall/vm.py#L53-L97" target="_blank" rel="noopener">the part of bytecode dispatch</a> in <code>bytefall</code> VM, but also make it possible to run <code>pdb</code> in <code>bytefall</code> VM like the way it is used in a normal Python runtime.</p><p>But it’s just a part of implementation of this feature, we still need to make some modifications to make it work properly. If you are interested in it, you can also check out <a href="https://github.com/NaleRaphael/bytefall/blob/ee207a1e9e9fc40cd54f9ccac1e1cb61b12c27dc/bytefall/_compat/tracing.py#L28-L69" target="_blank" rel="noopener">this file</a> for the <code>Pdb</code> wrapper I wrote.</p><h2 id="further-reading"><a class="header-anchor" href="#further-reading"></a>Further reading</h2><p>If you are interested in this topic, I recommend you read this nice article: <a href="https://nedbatchelder.com/text/trace-function.html" target="_blank" rel="noopener">“How C trace functions really work - by Ned Batchelder”</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> devlog </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to create a built-in `frame` object in Python?</title>
      <link href="/blog/2020/03/11/devlog_create_a_builtin_frame_object/"/>
      <url>/blog/2020/03/11/devlog_create_a_builtin_frame_object/</url>
      
        <content type="html"><![CDATA[<p>Recently, I ran into a problem about using <code>pdb</code> in <a href="https://github.com/NaleRaphael/bytefall" target="_blank" rel="noopener"><code>bytefall</code></a> (a Python virtual machine implemented in Python). It’s not a bug-like problem, but just a curiousity-triggered one.</p><p><code>pdb</code> worked fine in <code>bytefall</code>, but all internal execution flow will be revealed once <code>pdb.set_trace()</code> is called in a user script. It might be annoying if users don’t want to get those information.</p><p>Then, a question comes to my mind:<br><em>Is it possible to make a switch to run <code>pdb</code> with/without revealing the internal of <code>bytefall</code> virtual machine?</em></p><p>During the developing of this feature, I found that the <a href="https://github.com/NaleRaphael/bytefall/blob/ee207a1e9e9fc40cd54f9ccac1e1cb61b12c27dc/bytefall/pyframe.py#L13" target="_blank" rel="noopener"><code>pyframe.Frame</code></a> object cannot be used as a duck-typed <code>frame</code> object while using command <code>ll</code> in <code>pdb</code>. The error we got is: <code>TypeError: module, class, method, function, traceback, frame, or code object was expected, got Frame</code>.</p><h2 id="quack-you-should-give-me-a-frame-object"><a class="header-anchor" href="#quack-you-should-give-me-a-frame-object"></a>Quack, you should give me a <code>frame</code> object</h2><p>Here is the simplified traceback of that error:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pdb.py::do_longlist</span><br><span class="line">-&gt; pdb.py::getsourcelines</span><br><span class="line">-&gt; inspect.py::findsource</span><br><span class="line">-&gt; inspect.py::getsourcefile</span><br><span class="line">-&gt; inspect.py::getfile</span><br><span class="line"></span><br><span class="line"># Inside `inspect.py::getfile`, `inspect.py::isframe` is called.</span><br><span class="line"># And this is how `inspect.py::isframe` implemented:</span><br><span class="line">def isframe(object):</span><br><span class="line">    return isinstance(object, types.FrameType)</span><br></pre></td></tr></table></figure><p>As we know that we can make it pass the check of <code>isinstance(obj, SomeType)</code> by making class of <code>obj</code> inheriting <code>SomeType</code>. e.g.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span><span class="params">(list)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">print(isinstance(MyList(), list))</span><br><span class="line"><span class="comment"># Output: True</span></span><br></pre></td></tr></table></figure><p>But we are not allowed to do the same thing for <code>frame</code>.</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> types</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span><span class="params">(types.FrameType)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">print(isinstance(MyFrame(), types.FrameType))</span><br><span class="line"><span class="comment"># Got `TypeError: type 'frame' is not an acceptable base type`</span></span><br></pre></td></tr></table></figure><p>Why? After googling, I found a <a href="https://stackoverflow.com/questions/16056574" target="_blank" rel="noopener">related post on stackoverflow</a> talking about this exception. In short, <code>Py_TPFLAGS_BASETYPE</code> is not set in the implementation of <code>PyFrameObject</code>, thus it cannot be subclassed. We can see that in <a href="https://github.com/python/cpython/blob/725cbce25084a67ad7ff48b75cca3e240ef57606/Objects/frameobject.c#L611-L644" target="_blank" rel="noopener">cpython/Objects/frameobject.c</a>.</p><p>And here is the definition of that flag:</p><blockquote><ul><li>Py_TPFLAGS_BASETYPE<br>This bit is set when the type can be used as the base type of another type. If this bit is clear, the type cannot be subtyped (similar to a “final” class in Java).</li></ul></blockquote><p>(further reading: <a href="https://www.python.org/dev/peps/pep-0253/#preparing-a-type-for-subtyping" target="_blank" rel="noopener">PEP 253 – Subtyping Built-in Types</a>, <a href="http://python-history.blogspot.com/2009/04/metaclasses-and-extension-classes-aka.html" target="_blank" rel="noopener">Python history - Metaclasses and extension classes (a.k.a “The Killer Joke”)</a>)</p><h2 id="it-not-the-time-to-give-up-yet"><a class="header-anchor" href="#it-not-the-time-to-give-up-yet"></a>It not the time to give up yet</h2><p>Though it’s a frustrating news, I started searching with keywords like “Python, create builtin object”. Then something interesting showed up: <a href="https://stackoverflow.com/questions/27138440" target="_blank" rel="noopener">How to create a traceback object</a>.</p><p>Said by the answerer @abarnert in that post:</p><blockquote><p>The <code>PyTraceBack</code> type is not part of the public API. But (except for being defined in the Python directory instead of the Object directory) it’s built as a C API type, just not documented. … well, there’s no <code>PyTraceBack_New</code>, but there is a <code>PyTraceBack_Here</code> that constructs a new traceback and swaps it into the current exception info.</p></blockquote><p>It reminded me of one thing I missed before: “If one thing is an object, then there (usually) should be a <strong>constructor</strong>.”</p><p>And, yeah, there is a function called <a href="https://github.com/python/cpython/blob/725cbce25084a67ad7ff48b75cca3e240ef57606/Objects/frameobject.c#L782-L790" target="_blank" rel="noopener"><code>PyFrame_New</code></a>.</p><p>Next, we need to figure out how to call <code>PyFrame_New()</code> from Python side.</p><p>Since it’s a C function, we can try to access it through <code>ctypes.pythonapi</code>. Roughly speaking, this is what we want to do:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">frame = ctypes.pythonapi.PyFrame_New(</span><br><span class="line">    ...,  <span class="comment"># thread state</span></span><br><span class="line">    ...,  <span class="comment"># a code object</span></span><br><span class="line">    ...,  <span class="comment"># a dict of globals</span></span><br><span class="line">    ...   <span class="comment"># a dict of locals</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="play-with-ctypes"><a class="header-anchor" href="#play-with-ctypes"></a>Play with <code>ctypes</code></h2><p>There are a few things worth noting:</p><ol><li><p>Before calling a <code>c_func</code>, its <code>argtypes</code> and <code>restype</code> should be given.</p></li><li><p>According to the signature of <code>PyFrame_New</code>, there is a pointer of <code>PyThreadState</code> object should be given. However, it isn’t an object that we can access in Python directly.</p></li><li><p>As @abarnert mentioned:</p><blockquote><p>Also, both are CPython-specific, require not just using the C API layer but using undocumented types and functions that could change at any moment, and offer the potential for new and exciting opportunities to segfault your interpreter.</p></blockquote><p>Compatibility and robustness of our implementation should be taken care of.</p></li></ol><p>Let’s start doing this step by step (to avoid confusion and being affected by the changes among versions, here we are taking CPython 3.7 as the runtime):</p><ol><li><p>According to point 1, we should rewrite the code above into this:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">ctypes.pythonapi.PyFrame_New.argtypes = (</span><br><span class="line">    ...,    <span class="comment"># PyThreadState*</span></span><br><span class="line">    ...,    <span class="comment"># PyCodeObject*</span></span><br><span class="line">    ...,    <span class="comment"># PyObject*</span></span><br><span class="line">    ...     <span class="comment"># PyObject*</span></span><br><span class="line">)</span><br><span class="line">ctypes.pythonapi.PyFrame_New.restype = (</span><br><span class="line">    ...     <span class="comment"># PyFrameObject*</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">frame = ctypes.pythonapi.PyFrame_New(</span><br><span class="line">    ...,    <span class="comment"># thread state</span></span><br><span class="line">    ...,    <span class="comment"># a code object</span></span><br><span class="line">    ...,    <span class="comment"># a dict of globals</span></span><br><span class="line">    ...     <span class="comment"># a dict of locals</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>But there is a problem: “Except <code>ctypes.py_object</code>, there are no other types of Python object defined as <code>py_threadstate</code>, <code>py_codeobject</code> and <code>py_frameobject</code>.”</p><p>Typically, we have to define some classes inheriting <code>ctypes.Structure</code> with <code>_fields_</code> in which all members of those internal types are defined. Then assign those classes to <code>argtypes</code> and <code>restype</code>. Take <code>PyThreadState</code> as an example, we have to deal with <a href="https://github.com/python/cpython/blob/97e92dbba9d7840a5068d7878d1393d36229882b/Include/pystate.h#L212-L304" target="_blank" rel="noopener"><strong>THESE THINGS</strong></a>.</p><p>Ok, it sounds like a complicated work to do, but there is actually a shortcut for this. Let’s take a look at the signature of <code>PyFrame_New</code> again:</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyFrameObject*</span><br><span class="line">PyFrame_New(PyThreadState *tstate, PyCodeObject *code,</span><br><span class="line">            PyObject *globals, PyObject *locals)</span><br><span class="line">&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p><a name="ctypes_pointer_as_argument_type"></a><br>From the aspect of C, what we have to do is passing <strong>pointers of objects</strong> to the function. Therefore, we can use <code>ctypes.POINTER(...)</code> as a type for <code>PyThreadState*</code>, <code>PyCodeObject*</code>. (reminder: we just need to use <code>ctypes.py_object</code> for <code>PyObject*</code>)</p><p>According to the <a href="https://docs.python.org/3.7/library/ctypes.html#ctypes.POINTER" target="_blank" rel="noopener">documentation</a> of <code>ctypes.POINTER(...)</code>, it takes a type defined in <code>ctypes</code> as argument. But what is the type of pointer we need to use?</p><p>As we know that a pointer is a container storing memory address, what argument of <code>ctypes.POINTER(...)</code> takes depends on the architecture of your computer. That is, we should use <code>ctypes.c_ulong</code> for x64 and <code>ctypes.c_uint</code> for x86.</p><p>By doing this, we are also increasing the compatibility of our implementation. And the progress of our implementation is shown as below:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check whether we are on a x64 or x86 platform by checking the size of `void*`</span></span><br><span class="line"><span class="comment"># 8-byte for x64, 4-byte for x86</span></span><br><span class="line">P_SIZE = ctypes.sizeof(ctypes.c_void_p)</span><br><span class="line">IS_X64 = P_SIZE == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">P_MEM_TYPE = ctypes.POINTER(ctypes.c_ulong <span class="keyword">if</span> IS_X64 <span class="keyword">else</span> ctypes.c_uint)</span><br><span class="line"></span><br><span class="line">ctypes.pythonapi.PyFrame_New.argtypes = (</span><br><span class="line">    P_MEM_TYPE,         <span class="comment"># PyThreadState *tstate</span></span><br><span class="line">    P_MEM_TYPE,         <span class="comment"># PyCodeObject *code</span></span><br><span class="line">    ctypes.py_object,   <span class="comment"># PyObject *globals</span></span><br><span class="line">    ctypes.py_object    <span class="comment"># PyObject *locals</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># We can use `ctypes.py_object` for this. Because we are going to </span></span><br><span class="line"><span class="comment"># manipulate it in Python instead of C.</span></span><br><span class="line">ctypes.pythonapi.PyFrame_New.restype = ctypes.py_object     <span class="comment"># PyFrameObject*</span></span><br><span class="line"></span><br><span class="line">frame = ctypes.pythonapi.PyFrame_New(</span><br><span class="line">    ...,    <span class="comment"># thread state</span></span><br><span class="line">    ...,    <span class="comment"># a code object</span></span><br><span class="line">    ...,    <span class="comment"># a dict of globals</span></span><br><span class="line">    ...     <span class="comment"># a dict of locals</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>Now we are going to pass arguments to the function call <code>PyFrame_New()</code>.<br>To make it easier to be understood, here we define a simple function <code>greet()</code> for setting 2nd argument up later, and directly use <code>globals()</code> and <code>locals()</code> as the 3rd and 4th argument respectively. As for the first argument <code>tstate</code>, we will talk about it in next step.</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">P_SIZE = ctypes.sizeof(ctypes.c_void_p)</span><br><span class="line">IS_X64 = P_SIZE == <span class="number">8</span></span><br><span class="line">P_MEM_TYPE = ctypes.POINTER(ctypes.c_ulong <span class="keyword">if</span> IS_X64 <span class="keyword">else</span> ctypes.c_uint)</span><br><span class="line"></span><br><span class="line">ctypes.pythonapi.PyFrame_New.argtypes = (</span><br><span class="line">    P_MEM_TYPE,         <span class="comment"># PyThreadState *tstate</span></span><br><span class="line">    P_MEM_TYPE,         <span class="comment"># PyCodeObject *code</span></span><br><span class="line">    ctypes.py_object,   <span class="comment"># PyObject *globals</span></span><br><span class="line">    ctypes.py_object    <span class="comment"># PyObject *locals</span></span><br><span class="line">)</span><br><span class="line">ctypes.pythonapi.PyFrame_New.restype = ctypes.py_object     <span class="comment"># PyFrameObject*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple function for demonstration</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">frame = ctypes.pythonapi.PyFrame_New(</span><br><span class="line">    ...,    <span class="comment"># thread state</span></span><br><span class="line">    ctypes.cast(id(greet.__code__), P_MEM_TYPE),    <span class="comment"># a code object</span></span><br><span class="line">    globals(),    <span class="comment"># a dict of globals</span></span><br><span class="line">    locals()      <span class="comment"># a dict of locals</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Seeing the 2nd argument of <code>PyFrame_New()</code> above? Remember that we have defined the 2nd argument type as <code>P_MEM_TYPE</code>, which is actually a pointer. So that passing <code>greet.__code__</code> directly is invalid and we will get an error like the following one:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctypes.ArgumentError: argument 2: &lt;class &apos;TypeError&apos;&gt;: expected LP_c_ulong instance instead of code</span><br></pre></td></tr></table></figure><p>To meet the requirement defined in <code>PyFrame_New.argtypes</code>, we have to cast <code>greet.__code__</code> into a C pointer. Luckily, in CPython, we can get memory address of a Python object through <code>id()</code>. After that, we just need to use <code>ctypes.cast()</code> to cast it into <code>P_MEM_TYPE</code> defined above.</p></li><li><p>Nice! We are about to finish the function call.<br>Like <code>PyFrameObject</code>, we are not able to create a <code>PyThreadState</code> object directly. Besides, a <code>PyThreadState</code> object usually relates to the interpreter you are using, rather than threads created by <code>threading</code> module. (further reading: <a href="https://docs.python.org/3.7/c-api/init.html#thread-state-and-the-global-interpreter-lock" target="_blank" rel="noopener">Thread State and the Global Interpreter Lock</a>)</p><p>To access a <code>PyThreadState</code> object, it should be done through calling <code>PyThreadState_Get()</code>. Since it’s a part of C-API, we have to set <code>argtypes</code> and <code>restype</code> for it, too.</p><p>According to the <a href="https://github.com/python/cpython/blob/627e7bc1bb203b6472af567f2effee952c34b34c/Python/pystate.c#L706-L714" target="_blank" rel="noopener">signature of it</a>, it takes no argument and returns a pointer of <code>PyThreadState</code>.</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PyThreadState *</span><br><span class="line">PyThreadState_Get(<span class="keyword">void</span>)</span><br><span class="line">&#123; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure><p>As the same concept mentioned in <a href="#ctypes_pointer_as_argument_type">previous step</a>, this is the configuration:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctypes.pythonapi.PyThreadState_Get.argtypes = <span class="literal">None</span></span><br><span class="line">ctypes.pythonapi.PyThreadState_Get.restype = P_MEM_TYPE</span><br></pre></td></tr></table></figure><p>Finally, the whole script for creating a <code>frame</code> object will be:</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">P_SIZE = ctypes.sizeof(ctypes.c_void_p)</span><br><span class="line">IS_X64 = P_SIZE == <span class="number">8</span></span><br><span class="line"></span><br><span class="line">P_MEM_TYPE = ctypes.POINTER(ctypes.c_ulong <span class="keyword">if</span> IS_X64 <span class="keyword">else</span> ctypes.c_uint)</span><br><span class="line"></span><br><span class="line">ctypes.pythonapi.PyFrame_New.argtypes = (</span><br><span class="line">    P_MEM_TYPE,         <span class="comment"># PyThreadState *tstate</span></span><br><span class="line">    P_MEM_TYPE,         <span class="comment"># PyCodeObject *code</span></span><br><span class="line">    ctypes.py_object,   <span class="comment"># PyObject *globals</span></span><br><span class="line">    ctypes.py_object    <span class="comment"># PyObject *locals</span></span><br><span class="line">)</span><br><span class="line">ctypes.pythonapi.PyFrame_New.restype = ctypes.py_object     <span class="comment"># PyFrameObject*</span></span><br><span class="line"></span><br><span class="line">ctypes.pythonapi.PyThreadState_Get.argtypes = <span class="literal">None</span></span><br><span class="line">ctypes.pythonapi.PyThreadState_Get.restype = P_MEM_TYPE</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line">frame = ctypes.pythonapi.PyFrame_New(</span><br><span class="line">    ctypes.pythonapi.PyThreadState_Get(),    <span class="comment"># thread state</span></span><br><span class="line">    ctypes.cast(id(greet.__code__), P_MEM_TYPE),    <span class="comment"># a code object</span></span><br><span class="line">    globals(),    <span class="comment"># a dict of globals</span></span><br><span class="line">    locals()      <span class="comment"># a dict of locals</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h2 id="anything-funny-to-do-with-this-created-frame"><a class="header-anchor" href="#anything-funny-to-do-with-this-created-frame"></a>Anything funny to do with this created <code>frame</code>?</h2><p>Yeah! As the problem mentioned at the beginning, we can start playing with <code>pdb</code> right now.<br>And we will talk about that in the next article.</p>]]></content>
      
      
      
        <tags>
            
            <tag> devlog </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hosting code coverage report for a project targeting multiple Python versions by Travis CI and Github Pages</title>
      <link href="/blog/2020/02/26/travis_ci_for_multi_py_coverage/"/>
      <url>/blog/2020/02/26/travis_ci_for_multi_py_coverage/</url>
      
        <content type="html"><![CDATA[<p>In the past few days, I was finding a solution for:</p><ol><li>running tests with code coverage for a project targeting multiple Python versions automatically</li><li>public and easily accessible coverage report</li></ol><p>To meet the requirements of point 1, we can run <a href="https://github.com/pytest-dev/pytest" target="_blank" rel="noopener">pytest</a> and <a href="https://github.com/pytest-dev/pytest-cov" target="_blank" rel="noopener">pytest-cov</a> (in which <a href="https://github.com/nedbat/coveragepy" target="_blank" rel="noopener">coverage.py</a> is integrated) on <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>.</p><p>And thanks for the powerful <a href="https://github.com/nedbat/coveragepy" target="_blank" rel="noopener">coverage.py</a>, it is easy to generate a summarized report of code coverage for multiple Python versions by the following steps:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Just run this command repeatedly for each virtual environment ---</span></span><br><span class="line">$ COVERAGE_FILE=[name_of_coverage_file] python -mpytest --cov=[module_name] ./tests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then, use this command to combine data files.</span></span><br><span class="line"><span class="comment"># Note that name of data file should be in the format of `.coverage.[suffix]`</span></span><br><span class="line"><span class="comment"># ref: https://coverage.readthedocs.io/en/coverage-5.0.3/cmd.html#combining-data-files</span></span><br><span class="line">$ python -mcoverage combine</span><br></pre></td></tr></table></figure><h2 id="use-third-party-services-or-play-with-complex-settings"><a class="header-anchor" href="#use-third-party-services-or-play-with-complex-settings"></a>Use third party services or play with complex settings?</h2><p>As for point 2, it took me a while to make a decision. Though there are several existing awesome services like <a href="https://codecov.io/" target="_blank" rel="noopener">codecov</a>, <a href="https://coveralls.io/" target="_blank" rel="noopener">coverall</a>, I wonder if I could achieve it without those services.</p><p>To do that, I have to figure out a way to access data files of code coverage generated in each single CI job (environment). However, it’s unlike Jenkins and CircleCI, you cannot access/share artifacts generated by jobs by simply adding some operations in your <code>.travis.yml</code>. Though it’s a general concept of CI jobs and it’s also stated in <a href="https://docs.travis-ci.com/user/build-stages/#data-persistence-between-stages-and-jobs" target="_blank" rel="noopener">official documentation</a>:</p><blockquote><p>It is important to note that jobs do not share storage, as each job runs in a fresh VM or container. If your jobs need to share files (e.g., using build artifacts from the “Test” stage for deployment in the subsequent “Deploy” stage), you need to use an external storage mechanism such as S3 and a remote scp server.</p></blockquote><p>Oh… Third party service is still required?</p><p>After rethinking about this problem, it seems <a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> is a good candidate as a solution. However, it requires some interactions between Travis CI and Github. Therefore, I started googling with keywords like <code>travis ci push back to github</code>.</p><p>Then, yeah, a good article emerged from the sea: <a href="https://gist.github.com/willprice/e07efd73fb7f13f917ea" target="_blank" rel="noopener">How to set up TravisCI for projects that push back to github</a></p><p>It solved a part of problem. The remaining one is: <span style="color: orange">“How can I access those data files of code coverage after each CI job is done?”</span><br>It somehow seems that we are getting back to the starting point again. But, it isn’t.</p><h2 id="the-complicated-but-not-difficult-part"><a class="header-anchor" href="#the-complicated-but-not-difficult-part"></a>The complicated but not difficult part</h2><p>Since we known that we could authorize Travis CI to push files back to our own Github repository, we could also playing with branches. Here is the strategy:</p><ol><li>Define a test stage containing jobs running tests on different Python version.</li><li>After a job is done, push the data file of code coverage back to specific branch.</li><li>While all tests are done, we enter to the next stage for combining data and generating report. In this stage, we checkout those data files from each branch for data storage.</li></ol><p>And I implemented it in <a href="https://github.com/NaleRaphael/travis-multi-py-coverage" target="_blank" rel="noopener">this repository</a>. All operations related to the strategy mentioned above are written in the file <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/utils.sh" target="_blank" rel="noopener">.travis/utils.sh</a>, and the workflows of running tests and generate report of code coverage are written in <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/runtests.sh" target="_blank" rel="noopener">.travis/runtests.sh</a> and <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/gen_report.sh" target="_blank" rel="noopener">.travis/gen_report.sh</a> respectively.</p><p>There are few things worth noting:</p><ul><li><p><code>create_branch_for_coverage</code><br>We create <span style="color: orange">orphan branches</span> for tracking coverage files only. And the argument <code>--orphan</code> make these branches being history-independent to the main branch (master) of our project. It’s a cool technique for such purpose, and there are more <a href="https://stackoverflow.com/a/13203015" target="_blank" rel="noopener">cool use cases here</a>.</p></li><li><p><code>pull_branch_for_coverage</code><br>By default, Travis CI pulls only <span style="color: orange">one branch</span> into docker container of a job (if it is triggered by <code>master</code> branch, then it pulls that branch).<br>Therefore, to commit code coverage data to corresponding branch, we have to pull that branch to local first. And that’s why you can see this function is called in both <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/runtests.sh" target="_blank" rel="noopener">.travis/runtests.sh</a> and <a href="https://github.com/NaleRaphael/travis-multi-py-coverage/blob/master/.travis/gen_report.sh" target="_blank" rel="noopener">.travis/gen_report.sh</a>.</p></li><li><p><code>commit_artifacts</code><br>Argument <code>--allow-empty</code> in command <code>git-commit</code> is necessary for this workflow, because there might be no changes in code coverage. e.g. commits for fixing typo, documentation…</p>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">commit_artifacts</span></span>() &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    git commit -q --allow-empty -m <span class="string">"Travis build: <span class="variable">$TRAVIS_BUILD_NUMBER</span>"</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>use argument <code>-q</code> to silence output message<br><span style="color: red">For security reasons.</span> As <a href="https://gist.github.com/willprice/e07efd73fb7f13f917ea#gistcomment-1845535" target="_blank" rel="noopener">this comment</a> from that post created by willprice.</p></li></ul><p>After setting up all these things and push them to Github, Travis should be ready and work normally. And you can check the coverage report hosted on Github Pages of your repository (which should be <code>https://[your_github_user_name].github.io/[repo_name]</code>)</p><h2 id="postscript"><a class="header-anchor" href="#postscript"></a>Postscript</h2><p>Here is another concern taken before making the decision mentioned above:</p><blockquote><p>Instead of creating multiple branches for coverage files, is it good to push all those files to a single branch?</p></blockquote><p>In my opinion,</p><ol><li><p>Keeping one branch for each single Python version is not a bad thing, it makes us able to focus on what should be done in a single CI job.<br>Besides, CI jobs are executed <strong>parallelly</strong>. With this strategy, we can take each branch as a temporary workspace for corresponding job, and it reduces the interference among jobs.</p></li><li><p>We can also merge those branches to a single branch after the whole pipeline is done. Deleting those branches is also an optional post-action.</p></li><li><p>It is easier to checkout files from multiple branches, and it is time independent for each job in a single CI pipeline.</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                           timeline</span><br><span class="line">branch\commit  [job_1]      [job_2]      [job_3]</span><br><span class="line">branch_py35    j1_py35  &lt;-  j2_py35  &lt;-  j3_py35</span><br><span class="line">branch_py36    j1_py36  &lt;-  j2_py36  &lt;-  j3_py36</span><br><span class="line">branch_py37    j1_py37  &lt;-  j2_py37  &lt;-  j3_py37</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"># Checkout files from each branch</span><br><span class="line">combination    j1_all   &lt;-  j2_all   &lt;-  j3_all</span><br></pre></td></tr></table></figure><p>If we push every coverage file of different version to a single branch, commit history becomes as the following graph:</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            [           job_1           ]      [           job_2           ]</span><br><span class="line">branch      j1_py35 &lt;- j1_py36 &lt;- j1_py37  &lt;-  j2_py36 &lt;- j2_py35 &lt;- j2_py37</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"># Note that order of commits is not guaranteed to be sorted</span><br><span class="line"># Use `git rebase` to combine multiple commits</span><br><span class="line">combination            j1_all              &lt;-             j2_all</span><br></pre></td></tr></table></figure><p>We can get the same result with different approach. However, once there is a failure occuring in a job, we need to do a few more steps to handle it.</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               [job_1]      [job_2]</span><br><span class="line">branch_py35    j1_py35  &lt;-  j2_py35</span><br><span class="line">branch_py36     (NA*)   &lt;-  j2_py36</span><br><span class="line">branch_py37    j1_py37  &lt;-  j2_py37</span><br><span class="line"></span><br><span class="line">*Job is failed, so that there is no commit.</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">combination      NA     &lt;-  j2_all</span><br></pre></td></tr></table></figure><p>Since there is a failure at <code>branch_py36</code> in <code>job_1</code>, CI pipeline will be terminated. Hence that there is no combined coverage files at branch <code>combination</code>.<br>After pushing a hotfix to start pipeline again, we just need to checkout the latest commit from each branch. It means that the next run of CI pipeline won’t be affected by previous failure.</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            [          job_1          ]       [           job_2           ]</span><br><span class="line">branch      j1_py35 &lt;- (NA*) &lt;- j1_py37  &lt;-  j2_py36 &lt;- j2_py35 &lt;- j2_py37</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">combination             NA               &lt;-             j2_all</span><br></pre></td></tr></table></figure><p>Due to the parallel execution of CI jobs, <code>j1_py37</code> is still pushed to the branch. In this case, there are only 2 commits in <code>job_1</code>.<br>Though that it doesn’t affect the execution of <code>job_2</code>, the missing commit will increase the difficulty of backtracing on <code>branch</code>.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> ci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMA-262-3: chapter 4 - scope chain</title>
      <link href="/blog/2019/10/01/ECMA-262-3_ch_4/"/>
      <url>/blog/2019/10/01/ECMA-262-3_ch_4/</url>
      
        <content type="html"><![CDATA[<p>原文連結：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">ECMA-262-3: chapter 4 - scope chain</a></p><p>以下內容會照著原文的架構書寫，並加入個人的解讀與其他相關的內容進去（定位不是翻譯文）。</p><h2 id="introduction"><a class="header-anchor" href="#introduction"></a>Introduction</h2><blockquote><p>As we already know from the <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="noopener">second chapter</a> concerning the <em>variable object</em>, the data of an <a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="noopener">execution context</a> (variables, function declarations, and <strong>formal parameters</strong>* of functions) are stored as properties of the variables object.</p></blockquote><p>* 即 function signature 中的參數名稱，可見 MDN 的這篇關於 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_formal_parameter" target="_blank" rel="noopener">SyntaxError: missing formal parameter</a> 的說明</p><blockquote><p>Also, we know that the variable object is created and filled with initial values every time on <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#entering-the-execution-context" target="_blank" rel="noopener">entering the context</a>, and that its updating occurs at <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#code-" target="_blank" rel="noopener">code execution</a> phase.</p></blockquote><p>這段講到的東西其實就是我們常聽到的一個概念： hoisting 。<br>每當進入一個 execution context （以下簡稱 EC ）時， variable object （以下簡稱 VO ）就會被建立出來並把該 scope 內的變數設為本身的 property 並初始化（設定為 undefined）。而在進入執行階段後才會更新 VO 內的各項 property。</p><p>而本章節主要在說明 EC 裡面的一個細節，也就是 <code>scope chain</code> 。</p><h2 id="definition"><a class="header-anchor" href="#definition"></a>Definition</h2><p>在講到 <code>scope chain</code> 之前，我們要知道什麼是 <code>scope</code> 。從比較簡單一點的角度來看，你可以想像成是下面這句話：</p><blockquote><p>「你目前處於什麼位置，在你的視野裡能看到哪些東西？」</p></blockquote><p>中的<code>視野</code>。是的，也跟 <code>scope</code> 這個單字的意義一樣。</p><p>也就是說，如果你現在站在三年一班的的講台上，那你應該是看不到三年二班的杰倫同學才對。因為你的視野就是被限制在三年一班的環境裡，除非這兩個班之間的牆被打了個洞，或是教室的蓋法比較特殊，造成類似 <a href="https://stackoverflow.com/questions/4198906" target="_blank" rel="noopener">Python 2 中的 list comprehension 裡的變數洩漏</a>這項問題。</p><!-- 這時，廣播響起了訓導主任的聲音說道要找杰倫同學，而你也想去訓導處看看是發生了什麼事情。在還沒反應過來時，你身邊的一個藍色貓型機器人從他的口袋拿出了一個字卡，上面寫著： `scope chain` 。是的，如果你不知道訓導處在哪棟大樓，那麼你要怎麼到達那裡呢？而你想到，訓導處是屬於學校底下的一個處室，所以應當能夠從校園地圖中找到訓導處的位置。而這也像是 `scope chain` 的功能：它會幫你由上而下地紀錄 scope 的順序（學校 -> 某大樓 -> 訓導處）， --><ul><li><p>補充：<br>在 Python 中，對 scope 的解析順序也是有先後之分的，依序為 <code>Local -&gt; Enclosed -&gt; Global -&gt; Built-in</code> ，其中 <code>Enclosed</code> 其實就是 <code>closure</code> 的概念。<br>而這個概念其實可以類比到這篇所提到的 <code>scope chain</code> ，因為都是在處理一個 scope 中的物件指向的是哪個東西。<br>也因為有這樣的解析順序，所以在 Python 中可以見到一些對 <code>import</code> 進來的物件再次做更細節的綁定，讓物件處於更貼近執行期間的 scope ，也減少變數名稱的解析時間（相對地增加效能）。<br>而關於 Python 對於 scope 的解析，除了<a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces" target="_blank" rel="noopener">官方文件</a>以外，也可以仔細咀嚼一下這篇文章 <a href="http://sebastianraschka.com/Articles/2014_python_scope_and_namespaces.html" target="_blank" rel="noopener">A Beginner’s Guide to Python’s Namespaces, Scope Resolution, and the LEGB Rule</a> 。</p>  <!-- TODO: check numpy source code --></li></ul><p>回到原文，由於我們知道 ECMAScript 允許我們在 function 裡面再建立一個 function ，並能將內層的那個 function 當作回傳值傳出，所以我們可以實作出下方範例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()()  <span class="comment">// console: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because:</span></span><br><span class="line"><span class="comment">// step 1:</span></span><br><span class="line"><span class="comment">//   foo()()</span></span><br><span class="line"><span class="comment">//   &lt;---&gt; which returns `bar`</span></span><br><span class="line"><span class="comment">// step 2:</span></span><br><span class="line"><span class="comment">//     bar()</span></span><br><span class="line"><span class="comment">//     &lt;---&gt; which executes `alert(x + y)`</span></span><br><span class="line"><span class="comment">//   a. While `y` does not exist in the scope of `bar`</span></span><br><span class="line"><span class="comment">//   but inside the scope of `foo`, we got `y` with the value `20`.</span></span><br><span class="line"><span class="comment">//   b. While `x` does not exist in the scope of `bar` and `foo`</span></span><br><span class="line"><span class="comment">//   but inside the scope of `global`, we got `x` with the value `10`.</span></span><br><span class="line"><span class="comment">//   c. Thus, `x + y` is `10 + 20`.</span></span><br></pre></td></tr></table></figure><p>之所以做到這個效果，是因為每個 EC 都有它自己的 VO （對於被呼叫的函數，則是建立 activated object ，以下簡稱 AO）。 EC 是隨著執行步驟一層一層地建立出來，而 VO/AO 也是同時跟著一層一層的串起。所以對於上面範例而言， “bar” 的 scope chain 就包含了： AO(bar), AO(foo), VO(global) 。</p><p>這也對應到原文中的引言：</p><blockquote><p><em>Scope chain</em> is related with an execution context a <em>chain of variable objects</em> which is used for variables lookup at <em>identifier resolution</em>*.</p></blockquote><p>* <code>identifier resolution</code> ：也就是名稱的解析。我們須藉著 scope chain 去解析出目前執行到的某個 identifier 到底是什麼。而關於 identifier 的定義，可以往回看 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener">ECMA-262-3-chapter-3-this</a> 裡面的說明，或是參考下一段的解說。</p><p>接著：</p><blockquote><p>The scope chain of a function context is created at function <em>call</em>* and consists of the <em>activation object</em> and the internal <em>[[Scope]]</em> property of this function.</p></blockquote><p>* scope chain 的建立是在一個函數<strong>被呼叫</strong>的時候</p><p>所謂的 <code>[[Scope]]</code> property ，是被定義在一個 activated EC 裡面的，紀錄著該 EC 能夠用來做 <code>identifier resolution</code> 的 scope chain ，其可以視為以下的一個物件架構：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">activeExecutionContext = &#123;</span><br><span class="line">  VO: &#123;...&#125;,  <span class="comment">// or AO</span></span><br><span class="line">  <span class="keyword">this</span>: thisValue,</span><br><span class="line">  Scope: [  <span class="comment">// Scope chain</span></span><br><span class="line">    <span class="comment">// list of all variable objects</span></span><br><span class="line">    <span class="comment">// for identifiers lookup (identifier resolution)</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="anchor-scope-definition" style="visibility:hidden;"></h6><p>而 <code>Scope</code> 可以被定義為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = AO + [[Scope]]</span><br></pre></td></tr></table></figure><p>若要以 ECMAScript 裡的物件來表示的話，我們可以分別：</p><ol><li><p>用 <code>array</code> 表示*：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Scope = [VOn, ..., VO2, VO1]; <span class="comment">// scope chain</span></span><br></pre></td></tr></table></figure><p>* 這邊 VO 的編號順序刻意與原文顛倒，是為了配合<a href="#function-activation">下文</a>所述的 VO 建立順序（數字越小代表越外層，也就是越早被建立的 VO）</p></li><li><p>用帶有 <code>__parent__</code> 的 <code>object</code> 表示：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;;</span><br><span class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;;</span><br><span class="line"><span class="comment">// etc.</span></span><br></pre></td></tr></table></figure></li></ol><p>另外原文提到：在 <code>ECMA-262-3 specification 10.1.4</code> 裡也有用 “a scope chain is a <em>list</em> of objects” 來描述，但暫時不理會在實作的層面上使用一個帶有 <code>__parent__</code> 的階層鍊也是一個作法，使用 <code>array</code> 來表示也是個比較貼近 <code>list</code> 的概念，所以原文以下都會使用這種方式來敘述。</p><h2 id="function-life-cycle"><a class="header-anchor" href="#function-life-cycle"></a>Function life cycle</h2><p>函數的生命週期可以被區分為 creation 和 activation (call) 兩個階段，以下就分別對這兩個階段進行討論。</p><h3 id="function-creation"><a class="header-anchor" href="#function-creation"></a>Function creation</h3><blockquote><p><em>[[Scope]]</em> is a hierarchical chain of all <em>parent</em> variable objects, which are above the current function context; the chain is saved to the function at its <em>creation</em>*.</p></blockquote><blockquote><p>Another moment which should be considered is that <em>[[Scope]]</em> in contrast with <em>Scope (Scope chain)</em> is the property of a <em>function</em> instead of a <em>context</em>**.</p></blockquote><p>* <code>[[Scope]]</code> 是在函數建立的階段就被建立出來，是靜態/不可變的（原文： statically/invariably），直到函數被摧毀（原文：function destruction）才消失。</p><p>** <code>[[Scope]]</code> 是函數的 property 而不是 context 的 property 。亦即：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.[[Scope]] = [</span><br><span class="line">  globalContext.VO  <span class="comment">// === Global</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="function-activation"><a class="header-anchor" href="#function-activation"></a>Function activation</h3><blockquote><p>High light here is that the activation object is the <em>first</em> element of the <em>Scope</em> array, i.e. added to the <em>front of scope chain</em>*:</p></blockquote><h6 id="anchor-scope-chain-creation-order" style="visibility:hidden;"></h6><p>* 當前被執行到的函數所建立的 AO 會是該 <code>scope chain</code> 的<span style="color:red">第一個</span>，也就如同<a href="#anchor-scope-definition">上方所述</a>。而 <code>scope chain</code> 也可以表示為以下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = AO|VO + [[Scope]]</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Scope = [AO].concat([[Scope]])</span><br></pre></td></tr></table></figure><p>這對於 <code>identifier resolution</code> 是一個非常重要的特性，因為在做解析時，我們必須從當前的 scope 開始尋找，只有在找不到對應的 identifier 時才會往上一層 scope （更大的 scope ，同時也是 scope chain 的下一個）開始搜尋，否則 identifier 的對照會被打亂。而 <code>identifier resolution</code> 在原文中的定義為：</p><blockquote><p><em>Identifier resolution</em> is a process of determination to which <strong>variable object</strong> in scope chain the variable (or the function declaration) belongs.</p></blockquote><p><code>identifier resolution</code> 這個演算法的回傳值會是一個 <code>Reference</code> 物件，詳情可以往回參考 <a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/#-reference-type" target="_blank" rel="noopener">Chapter 3. This - 4.1 Reference type</a> 或是 chapter 3 筆記的<a href="/8di-0eIeQF2FTPSjx_uLEA#Reference-type">這部分</a>。</p><p>而 <code>identifier resolution</code> 解析的順序，如同上面所說的，會從當前被執行到的函數所建立的 <code>AO</code> 開始做（也就是最深層的那個 scope），再依序往更上層去搜索。所以可以大概地視為下方這樣的行為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- definition of VO ---</span></span><br><span class="line"><span class="keyword">var</span> VO1 = &#123;<span class="attr">__parent__</span>: <span class="literal">null</span>, ... other data&#125;;  <span class="comment">// top scope</span></span><br><span class="line"><span class="keyword">var</span> VO2 = &#123;<span class="attr">__parent__</span>: VO1, ... other data&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> AO = &#123;<span class="attr">__parent__</span>: VOn, ... other data&#125;;    <span class="comment">// bottom scope</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- definition of scope chain ---</span></span><br><span class="line"><span class="comment">//      bottom      -&gt;      top</span></span><br><span class="line">Scope = [AO, VOn, ..., VO2, VO1]</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- algorithm of `identifier resolution` ---</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveIdentifier</span>(<span class="params">scopeChain, identifier</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> currentScope = scopeChain[<span class="number">0</span>]  <span class="comment">// start from `AO`</span></span><br><span class="line">  <span class="keyword">var</span> target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (currentScope &amp;&amp; !target) &#123;  <span class="comment">// if no scope can be explored or target is found, stop iteration</span></span><br><span class="line">    target = findIdentifier(currentScope, identifier)  <span class="comment">// if target is not found, return `null`</span></span><br><span class="line">    currentScope = currentScope.__parent__  <span class="comment">// update scope to be explored</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Reference.from(target)  <span class="comment">// convert `target` to an object of `Reference` type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- TODO: more details about scope chain and identifier resolution --><!-- TODO: brief introduction of identifier resolution in Python --><p>回到原文舉的例子，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// step_01</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// step_03</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z)  <span class="comment">// step_05</span></span><br><span class="line">  &#125;</span><br><span class="line">  bar()  <span class="comment">// step_04</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// step_02</span></span><br></pre></td></tr></table></figure><p>先記住重點：</p><ul><li>在 function creation 時：建立 <code>function.[[Scope]]</code></li><li>在 function call 時：建立 <code>activation object</code> 和 <code>scope chain</code></li></ul><p>再來我們看上面這個範例的執行流程：</p><ul><li><p>step_01: from the beginning; <code>foo</code> is created (<a href="#function-creation">creating <code>foo.[[Scope]]</code></a>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// variable object of `global` context</span></span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  foo: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// at `foo` creation</span></span><br><span class="line"><span class="xml">foo.[[Scope]] = [</span></span><br><span class="line"><span class="xml">  globalContext.VO</span></span><br><span class="line"><span class="xml">]</span></span><br></pre></td></tr></table></figure></li><li><p>step_02: After <code>foo</code> is called (creating creating activation object and <a href="#function-activation">scope chain</a> of <code>fooContext</code>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activation object of `foo` context:</span></span><br><span class="line">fooContext.AO = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  bar: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// scope chain of `foo` context:</span></span><br><span class="line"><span class="xml">fooContext.Scope = fooContext.AO + foo.[[Scope]]</span></span><br><span class="line"><span class="xml">// i.e.: </span></span><br><span class="line"><span class="xml">fooContext.Scope = [fooContext.AO, globalContext.VO]</span></span><br></pre></td></tr></table></figure></li><li><p>step_03: At creation of inner <code>bar</code> function (<a href="#function-creation">creating <code>bar.[[Scope]]</code></a>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">bar.[[Scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>step_04: at <code>bar</code> function call (creating activation object and <a href="#function-activation">scope chain</a> of <code>barContext</code>)</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// activation object of `bar` object</span></span><br><span class="line">barContext.AO = &#123;</span><br><span class="line">  z: <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scope chain of `bar` context:</span></span><br><span class="line">barContext.Scope = barContext.AO + bar.[[Scope]]</span><br><span class="line"><span class="comment">// i.e.:</span></span><br><span class="line">barContext.Scope = [barContext.AO, fooContext.AO, globalContext.VO]</span><br></pre></td></tr></table></figure></li><li><p>step_05:<br>綜合以上， <code>identifier resolution</code> 的結果為：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &quot;x&quot;</span><br><span class="line">-- barContext.AO // not found</span><br><span class="line">-- fooContext.AO // not found</span><br><span class="line">-- globalContext.VO // found - 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- &quot;y&quot;</span><br><span class="line">-- barContext.AO // not found</span><br><span class="line">-- fooContext.AO // found - 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- &quot;z&quot;</span><br><span class="line">-- barContext.AO // found - 30</span><br></pre></td></tr></table></figure><p>因此， <code>console.log(x + y + z)</code> 的結果為 <code>60</code></p></li></ul><h2 id="scope-features"><a class="header-anchor" href="#scope-features"></a>Scope features</h2><p>以下內容則是討論在 ECMAScript 中，有哪些特色是和函數的 <code>[[Scope]]</code> 有關。</p><h3 id="closures"><a class="header-anchor" href="#closures"></a>Closures</h3><blockquote><p>Actually, a <em>closure</em> is exactly a <em>combination of a function code and its [[Scope]] property</em>.</p></blockquote><blockquote><p>Thus, [[Scope]] contains that <em>lexical environment</em> (the parent variable object) in which function is <em>created</em>. Variables from higher contexts at the further function activation will be searched in this lexical (statically saved at creation) chain of variable objects.</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span></span><br><span class="line">  foo()  <span class="comment">// 10, not 20</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>以上述範例而言，在做 <code>identifier resolution</code> 的過程如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext.VO = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  foo: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">foo.[[Scope]] = [globalContext.VO]</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// --- after that IIFE is executed ---</span></span><br><span class="line"><span class="xml">iifeContext.AO = &#123;</span></span><br><span class="line"><span class="xml">  x: 20</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">iifeContext.Scope = [iifeContext.AO, globalContext.VO]</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// --- when `foo` is called, it try to resolve `x` from `foo.Scope`</span></span><br><span class="line"><span class="xml">fooContext.AO = &#123;&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// scope chain of `foo` context</span></span><br><span class="line"><span class="xml">fooContext.Scope = fooContext.AO + foo.[[Scope]]</span></span><br><span class="line"><span class="xml">// i.e.:                 ↓ here is the `x` we want to find</span></span><br><span class="line">fooContext.Scope = [&#123;&#125;, &#123;x:10, foo: &lt;reference to function&gt;&#125;]</span><br></pre></td></tr></table></figure><p>因此 <code>foo</code> 裡面的 <code>console.log(x)</code> 輸出的值仍是原本位於 global scope 的 <code>x</code> 的值。<br>簡而言之，就是因為 <code>foo</code> 的 <code>[[Scope]]</code> 早在自己被建立時就被確定了，而當時它的視野內能看到的就只有 <code>var x = 10</code> ，所以即使後來在 IIFE 內被呼叫到，也不會因為有一個同名的 <code>x</code> 而解析成新的這個 <code>x</code>。</p><p>而另一個經典的 closure 範例如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x, y])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">30</span></span><br><span class="line"><span class="keyword">var</span> bar = foo()  <span class="comment">// anonymous function is returned</span></span><br><span class="line"></span><br><span class="line">bar()  <span class="comment">// [10, 20]</span></span><br></pre></td></tr></table></figure><blockquote><p>Moreover, this example clearly shows that <code>[[Scope]]</code> of a function (in this case of the anonymous function returned from function <code>foo</code>) continues to exist <em>even after the context in which a function is created is already finished</em>.</p></blockquote><p>原文用這個例子來說明：我們可以從上述例子發現，即使在 <code>foo</code> 函數執行完畢後，其回傳的匿名函數的 <code>[[Scope]]</code> 還是一直存在著的。而這也是 clousure 的特色之一：它可以保留內部函數被建立時的 Scope*，且不被外部的 identifier 影響**！</p><p>* 前面提到的重點，在 function creation 時：建立 <code>function.[[Scope]]</code>。所以在上述例子中，匿名函數被建立時，它的 <code>[[Scope]]</code> 為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">anonymousContext.[[Scope]] = [fooContext.AO, globalContext.VO]</span><br><span class="line"><span class="comment">// i.e.:</span></span><br><span class="line">anonymousContext.[[Scope]] = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">foo</span>: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span>, x: 30, bar: undefined&#125;]</span></span><br></pre></td></tr></table></figure><p>** 因為每次在 scope chain 被建立時，<a href="#anchor-scope-chain-creation-order">都會把當前被 activated 的 scope 加到 scope chain 的最前面</a>，所以在做 <code>identifier resolution</code> 時，就可以從相對應的 activated context 的 scope 開始找起。也因此即使更外層有同名的 identifier 時，也不會解析成外層的那個 identifier 。</p><p>而關於 closure 更細節的討論，可以見<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="noopener">原文的第六章</a>。</p><h3 id="scope-of-functions-created-via-function-constructor"><a class="header-anchor" href="#scope-of-functions-created-via-function-constructor"></a>[[Scope]] of functions created via <code>Function</code> constructor</h3><p>但是這裡一個例外情況需要注意。當我們使用 <code>Function</code> 建構子在一個 closure 內建立一個函數時，會有這樣的情況：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">barFD</span> </span>&#123;  <span class="comment">// function declaration</span></span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> barFE = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// function expression</span></span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> barFn = <span class="built_in">Function</span>(<span class="string">'console.log(x); console.log(y);'</span>)</span><br><span class="line"></span><br><span class="line">  barFD()  <span class="comment">// 10, 20</span></span><br><span class="line">  barFE()  <span class="comment">// 10, 20</span></span><br><span class="line">  barFn()  <span class="comment">// 10, "ReferenceError: y is not defined"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>由上述例子可以發現，在 <code>barFn</code> 裡面的 <code>y</code> 並無法被存取到，而造成 <code>ReferenceError</code> 。我們回到原文繼續看：</p><blockquote><p>But it does not mean that function <code>barFn</code> has no internal <code>[[Scope]]</code> property (else it would not have access to the variable <code>x</code>)*.</p></blockquote><p>* 這並不代表透過 <code>Function</code> 建構子所建立的 <code>barFn</code> 就沒有了 <code>[[Scope]]</code> （否則在內部也無法存取到更上層的 <code>x</code> ）</p><blockquote><p>And the matter is that <code>[[Scope]]</code> property of functions created via the Function constructor contains <em>always only the global object</em>*.</p></blockquote><p>* 當我們使用 <code>Function</code> 建構子來動態地建立一個函數時，那個被建立出來的函數的 <code>[[Scope]]</code> <span style="color:red;">只會有 <code>global</code> 的 scope </span>。關於這點，可見 <a href="https://www-archive.mozilla.org/js/language/E262-3.pdf#%5B%7B%22num%22%3A731%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22FitB%22%7D%5D" target="_blank" rel="noopener">ECMAScript specification 3 - 15.3.2.1</a> 中的第 16 步（關鍵在下方引述的粗體字部分）：</p><blockquote><ol start="16"><li>Create a new Function object as specified in section 13.2 with parameters specified by parsing <em>P</em> as a $FormalParameterList_{opt}$ and boday specified by parsing <em>body</em> as a <em>FunctionBody</em>. <strong>Pass in a scope chain consisting of the global object as the <em>Scope</em> parameter.</strong></li></ol></blockquote><p>而關於透過 <code>Function</code> 建構子所建立出的函數與 closure 的討論，可以再參考<a href="https://www.bennadel.com/blog/1909-javascript-function-constructor-does-not-create-a-closure.htm" target="_blank" rel="noopener">這篇文章</a>。</p><h3 id="two-dimensional-scope-chain-lookup"><a class="header-anchor" href="#two-dimensional-scope-chain-lookup"></a>Two-dimensional Scope chain lookup</h3><p>關於 scope chain 用於 <code>identifier resolution</code> 上的細節，還有一個重點需要注意：</p><blockquote><p>… prototypes (if they are) of <strong>variable objects</strong> can be also considered — because of prototypical nature of ECMAScript: if property is not found directly in the object, its lookup proceeds in the <em>prototype chain</em>.</p></blockquote><p>記得 ECMAScript 是一個 prototype-based 語言嗎？我們討論的 VO 也是一個物件，所以當我們無法在 VO 裡面找到 property 的話，也會依照 prototype 的特性：往該物件的 prototype 去搜尋是否有該 property 。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dynamically add a property `x` to the prototype of `Object`</span></span><br><span class="line"><span class="comment">// Note that this operation affects all objects, use this carefully.</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No property `x` found in `foo`, so it continues to search in prototype of `foo`.</span></span><br><span class="line"><span class="comment">// (And type of `x` is `function`. However, `function` is also an `object`)</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.x)  <span class="comment">// hence we got `1` here</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dynamically add a property `x` to the prototype of `Object`</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">1</span></span><br><span class="line"><span class="comment">// We can also add a property `x` to the prototype of `Function`</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.x = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because the prototype chain of `foo` is:</span></span><br><span class="line"><span class="comment">// foo.__proto__: `Function`</span></span><br><span class="line"><span class="comment">// -&gt; foo.__proto__.__proto__: `Object`</span></span><br><span class="line"><span class="comment">// `Function` is the first element in this prototype chain, so that it will be resolved first</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.x)  <span class="comment">// hence we got `3` here</span></span><br></pre></td></tr></table></figure><p>所以原文提到，這也可看作是一個 2D 的 scope chain 搜尋：</p><ol><li>on scope chain links → 優先對每個 scope chain 上的 AO/VO 做搜尋</li><li>on every of scope chain link — deep into on prototype chain links → 如果在第一步都找不到目標，才會再對每個 scope chain 上 AO/VO 的 prototype chain 做更深入的搜尋</li></ol><p>但是因為 AO 並沒有 prototype ，所以我們在以下的範例可以看到這樣的輸出：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>在上述例子中，我們可以發現 <code>bar</code> 裡面的 <code>x</code> 並不是 <code>Object.prototype.x</code> 的值，而是位於 <code>foo</code> 裡面的 <code>x</code> 。這也證明了 <code>identifier resolution</code> 是優先搜索 scope chain ，如果沒有搜尋到結果才會再從 prototype chain 去尋找。同時也證明了：如果 <code>barContext.AO</code> 有 prototype ，那 <code>x</code> 的值會是 10 才對。</p><ul><li><p>補充：以上個範例來說，若以同樣的作法，我們把 <code>Object.prototype.x = 10</code> 改為 <code>Function.prototype.x = 10</code> ，並把 <code>foo</code> 裡面的 <code>var x = 20</code> 拿掉，結果為何？</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Function</span>.prototype.x = <span class="number">10</span></span><br><span class="line">foo()  <span class="comment">// output: ???</span></span><br></pre></td></tr></table></figure>  <details>      <summary><span style="color:green; font-weight:bold;">Click me to reveal the answer</span></summary>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReferenceError: x is not defined</span><br></pre></td></tr></table></figure><p>此時的 <code>Function.prototype.x = 10</code> 並沒有作用，但是若改為 <code>Object.prototype.x = 10</code> 則又能得到 <code>10</code> 的結果。這點值得再深入討論…（因為這可能與不同的 JavaScript 實作有關，所以從 source code 去找原因才會是根本之道）</p>  </details></li></ul><h3 id="scope-chain-of-the-global-and-eval-contexts"><a class="header-anchor" href="#scope-chain-of-the-global-and-eval-contexts"></a>Scope chain of the global and eval contexts</h3><p>這部分的話就沒有什麼特別有趣的東西囉，但是仍需要注意的是：</p><blockquote><p>The scope chain of the global context contains <em>only global object</em>. The context with code type “eval” has the same scope chain as a <em>calling context</em>.</p></blockquote><p>也就是說：</p><ol><li><p>global context 的 scope chain 只有 <code>global</code> object</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext.Scope = [Global]</span><br></pre></td></tr></table></figure></li><li><p>對於 <code>eval()</code> 所產生的內容，其 context 的 scope chain 跟 <code>callingContext</code> 相同：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">evalContext.Scope === callingContext.Scope</span><br></pre></td></tr></table></figure></li></ol><h3 id="affecting-on-scope-chain-during-code-execution"><a class="header-anchor" href="#affecting-on-scope-chain-during-code-execution"></a>Affecting on Scope chain during code execution</h3><p>而在 ECMAScript 裡，有兩個方式可以在執行階段（原文： at runtime code execution phase ）影響 scope chain ：</p><ol><li><code>with</code> block</li><li><code>try ... catch...</code> block</li></ol><p>因為這兩個 statement 會在 scope chain 的最前面加上自己的 scope ，也就是類似以下的情況：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = withObject|catchObject + AO|VO + [[Scope]]</span><br></pre></td></tr></table></figure><p>這部分可參考 chapter 3 筆記的 <a href="/8di-0eIeQF2FTPSjx_uLEA#Reference-type-and-null-this-value">Reference type and null this value</a></p><p>以下，我們直接以原文中較複雜的那個例子來說明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span>  <span class="comment">// step_01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;) &#123;  <span class="comment">// step_02</span></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span>  <span class="comment">// step_03</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">// step_04: 30</span></span><br><span class="line">  <span class="built_in">console</span>.log(y)  <span class="comment">// step_05: 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// step_06: 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// step_07: 30</span></span><br></pre></td></tr></table></figure><p>會有這樣的輸出，是因為：</p><ul><li><p>step_01:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context of `global` is initialized</span></span><br><span class="line">globalContext.VO = &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in current scope</span></span><br><span class="line">Scope = [withObject, globalContext]</span><br></pre></td></tr></table></figure></li><li><p>step_02: entering <code>with</code> block</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">withObject = &#123;<span class="attr">x</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in current scope</span></span><br><span class="line">Scope = [withObject, globalContext]</span><br><span class="line"><span class="comment">// i.e.</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">20</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>step_03: variable declaration<br>對於 <code>with</code> 區塊內的變數宣告的動作來說，我們會先在 local scope 尋找是否已經有相同的 <code>identifier</code> ：</p><ul><li>若有，則將其更新為新的數值（一樣會經過 <code>identifier resolution</code> 的過程去搜尋 scope chain）。</li><li>若無，則在 local scope 內建立這個 <code>identifier</code> 並賦值。</li></ul>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for `var x = 30`:</span></span><br><span class="line"><span class="comment">//        ↓ `x` is updated</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// for `var y = 30`</span></span><br><span class="line"><span class="comment">//          ↓ not found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">10</span>&#125;]</span><br><span class="line"><span class="comment">//                        ↓ found here, so we update it</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>step_04:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//        ↓ `x` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>step_05:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//                        ↓ `y` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">30</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>step_06:<br>在離開 <code>with</code> 區塊後， <code>with</code> 所建立的 scope 會被移除掉，所以變成：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//       ↓ scope created by `with` is removed</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure></li><li><p>step_07:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//        ↓ `x` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>step_08:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// search in scope chain</span></span><br><span class="line"><span class="comment">//               ↓ `y` is found here</span></span><br><span class="line">Scope = [&#123;<span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// hence we got:</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>補充：如果不是用 <code>with</code> 而是一般的 closure ，輸出則為：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>, y = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">30</span>, y = <span class="number">30</span></span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">// 30</span></span><br><span class="line">  <span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li></ul><p>至於 <code>try ... catch ...</code> 區塊，我們常見的用法如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'yo'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ex)  <span class="comment">// Error: "yo"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ex)  <span class="comment">// ReferenceError: ex is not defined</span></span><br></pre></td></tr></table></figure><p>其實在執行 <code>catch</code> 區塊時， scope chain 就會被修改成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> catchObject = &#123;</span><br><span class="line">  ex: <span class="xml"><span class="tag">&lt;<span class="name">exception</span> <span class="attr">object</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Scope = catchObject + AO|VO + [[Scope]]</span></span><br></pre></td></tr></table></figure><p>而在離開 <code>catch</code> 區塊後， <code>catch</code> 所建立的 scope 也會被移除掉，因此最後一行的結果是 <code>ReferenceError</code>。</p><h2 id="conclusion"><a class="header-anchor" href="#conclusion"></a>Conclusion</h2><p>在這個章節裡，我們討論到了許多關於 scope chain 的細節。基本上只要記住函數的生命週期中，分別在<a href="#function-creation">建立</a>與<a href="#function-activation">被呼叫(啟動)</a>時會做什麼處理，那麼後續對於 JavaScript 的執行流程和結果就不會有太大的問題了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMA-262-3: chapter 3 - this</title>
      <link href="/blog/2019/09/27/ECMA-262-3_ch_3/"/>
      <url>/blog/2019/09/27/ECMA-262-3_ch_3/</url>
      
        <content type="html"><![CDATA[<p>原文連結：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="noopener">ECMA-262-3: chapter 3 - this</a></p><p>以下內容會照著原文的架構書寫，並加入個人的解讀與其他相關的內容進去（定位不是翻譯文）。</p><h2 id="introduction"><a class="header-anchor" href="#introduction"></a>Introduction</h2><blockquote><p>Many programmers are used to thinking that the <code>this</code> keyword in programming languages is closely related to the object-oriented programming, exactly referring the newly created object by the constructor. In ECMAScript this concept is also implemented, however, as we will see, here it is not limited only to definition of created object.</p></blockquote><p>其實在我第一次嘗試去了解 JavaScript 的 <code>this</code> 時，也有點陷入如上文所說的情況。雖然以物件導向的觀點來理解 <code>this</code> 確實有不小的幫助，但是如果沒有更深入了解 Javascript 的 <code>this</code> ，很容易就會誤用。<br>像是之前在試做一個 todo list 時，為了動態地將一個 object method 綁定到新建立的按鈕上後，在該 method 裡面可以用 <code>this</code> 去抓到 object 本身的其他 method 來處理事情，卻發現 <code>this</code> 指向的是按鈕而不是原本那個 method 所屬的 object。（可見下方範例或此<a href="https://codepen.io/naleraphael/pen/NWKVxBy" target="_blank" rel="noopener">連結(codepen)</a>）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"manager.show(this)"</span>&gt;</span>Button 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- after clicked --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; Object &#123; id: "manager" &#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; &lt;button id="btn1" onclick="manager.show(this)"&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span>Button 2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- after clicked --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; &lt;button id="btn2"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &gt; click &#123; target: button#btn2, buttons: 0, clientX: 114, clientY: 17, layerX: 114, layerY: 17 &#125; --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="string">'manager'</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  show (arg) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> manager = <span class="keyword">new</span> Manager()</span><br><span class="line"><span class="keyword">let</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">'btn2'</span>)</span><br><span class="line">btn2.addEventListener(<span class="string">'click'</span>, manager.show, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><ul><li><p>補充:<br>JavaScript 中 <code>this</code> 的概念並不完全與 Python 的 <code>self</code> 一樣。<br>JavaScript 中 <code>this</code> 會指向實作的上一層對象，而 Python 的 <code>self</code> 則是用來表示物件方法(object method)內指向的物件本身（如同定義 <code>classmethod</code> ，一般 object method 的 signature 中第一個參數就是指向該 method 所綁定的物件本身）。<br>另外，Python 中的 <code>self</code> 並不是一個 builtin keyword ，只能算是一個<strong>約定成俗</strong>的一個慣用字，可見下方例子</p>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo2</span><span class="params">(me)</span>:</span></span><br><span class="line">    <span class="comment"># we can replace name of the first argument with another one</span></span><br><span class="line">    print(me)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  foo = Foo()</span><br><span class="line">  foo.echo()  <span class="comment"># &lt;__main__.Foo object at 0x7f12febd8a10&gt;</span></span><br><span class="line">  foo.echo2() <span class="comment"># &lt;__main__.Foo object at 0x7f12febd8a10&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="definition"><a class="header-anchor" href="#definition"></a>Definition</h2><blockquote><p><code>this</code> is directly related to the type of executable code of the context. The value is determined <em>on entering the context</em>* and is <em>immutable</em>** while the code is running in the context.</p></blockquote><p>* <code>this</code> 的值是在進入執行階段時才會被決定的，因此我們可以透過一些方式將一段有使用到 <code>this</code> 的程式碼重新綁定到其他物件上，使該段程式碼有不同的輸出。（後面會提到）<br>** <code>this</code> 是 immutable 的物件，也就是說一旦它的值被指定後，就無法再由後續的行為去改變那個值。</p><h2 id="this-value-in-the-global-code"><a class="header-anchor" href="#this-value-in-the-global-code"></a><code>this</code> value in the global code</h2><p>在 global scope 底下， <code>this</code> 指向的物件就是 <code>global object</code> 本身 (<code>Object [global]</code> in node.js, <code>Window</code> in browser)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// explicit property definition of the global object</span></span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// console: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// implicit definition via assigning to unqualified identifier</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// console: 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// also implicit via variable declaration because variable</span></span><br><span class="line"><span class="comment">// object of the global context is the global object itself</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.c);  <span class="comment">// console: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// equality check</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === global);  <span class="comment">// console: true; in node.js runtime</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);  <span class="comment">// console: true; in browser</span></span><br></pre></td></tr></table></figure><h2 id="this-value-in-the-function-code"><a class="header-anchor" href="#this-value-in-the-function-code"></a><code>this</code> value in the function code</h2><blockquote><p>The first (and, probably, the main) feature of <code>this</code> value in this type of code is that here it is not <em>statically bound</em>* to a function.</p></blockquote><blockquote><p>As it has been mentioned above, <em><code>this</code> value is determined on entering the context</em>**, and in case with a function code the value can be absolutely different every time.</p></blockquote><p>*, ** 如同上面所說的，<code>this</code> 並不是靜態地被綁定在一個函數裡面，而是在進入一個 execution context 後才被決定。</p><blockquote><p>However, at runtime of the code <code>this</code> value is immutable, i.e. it is not possible to assign a new value to it since <code>this</code> is not a variable (in contrast, say, with <em>Python programming language and its explicitly defined <code>self</code> object which can repeatedly be changed at runtime</em>*)</p></blockquote><p>* Python 中的 <code>self</code> 是可以被重新綁定的，詳情請見下方範例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># https://repl.it/@naleraphael/pyobjectselfrebinding</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.name = <span class="string">'Foo'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_my_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.name = <span class="string">'Bar'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_my_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(self.name)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">say_my_name_proxy</span><span class="params">(self, target)</span>:</span></span><br><span class="line">    self = target   <span class="comment"># rebind `self` with another object</span></span><br><span class="line">    self.say_my_name()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  bar = Bar()</span><br><span class="line">  bar.say_my_name()  <span class="comment"># Bar</span></span><br><span class="line">  bar.say_my_name_proxy(Foo())  <span class="comment"># Foo</span></span><br></pre></td></tr></table></figure><p>回到原文，我們用以下的範例來說明 <code>this</code> 指向的對象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  x: <span class="number">20</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === bar)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this = foo  // &lt;- SyntaxError: invalid assignment left-hand side</span></span><br><span class="line">    <span class="comment">// console.log(this.x)  // the line above is failed to be compiled, so this line won't work</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情況 1:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; bar.test()</span><br><span class="line"></span><br><span class="line">// Output in console</span><br><span class="line">true</span><br><span class="line">20</span><br></pre></td></tr></table></figure><ul><li>情況 2:</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// rebind `bar.test` to the new property `test` of `foo` object</span><br><span class="line">// so that `this` in the function `test` will point to the object `foo`</span><br><span class="line">&gt; foo.test = bar.test</span><br><span class="line">&gt; foo.test()</span><br><span class="line"></span><br><span class="line">// Output in console</span><br><span class="line">false</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h6 id="section-this-value-in-function-call-quote-2" style="visibility:hidden;"></h6><p>再來，原文提到</p><blockquote><p>First, in a usual function call, <strong><code>this</code> is provided by the caller which activates the code of the context</strong>, i.e. the parent context which calls the function. And the value of this is determined by the form of a call expression (in other words by the form how syntactically the function is called).</p></blockquote><p>也就是說，在一般的函數呼叫形式下，一段 execution context (EC) 內的 <code>this</code> 是由啟動 (activate) 該 EC 的 caller 提供。而 <code>this</code> 的值則是由呼叫的形式 (form of a call expression) 決定，也就是該函數的呼叫方式。以下為原文的範例，說明了一個函數透過不同的呼叫方式會讓其中的 <code>this</code> 指向不同的物件：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- example 01 ---</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()  <span class="comment">// console: global (in node.js runtime); Window (in browser)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor)   <span class="comment">// console: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In this expression, the parent context of `constructor` is `foo.prototype`</span></span><br><span class="line">foo.prototype.constructor()  <span class="comment">// console: foo.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- example 02 ---</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar()  <span class="comment">// console: foo, true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare an variable `exampleFunc`, and pass the address of `foo.bar` to it</span></span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc === foo.bar)  <span class="comment">// console: true, they point to the same address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In this expression, the parent context of `exampleFunc` is `global`</span></span><br><span class="line">exampleFunc()  <span class="comment">// console: global, false</span></span><br></pre></td></tr></table></figure><ul><li><p>補充 1:<br>接續上述的 example 02 ，如果我們又動態的改變了 <code>foo.bar</code> ，那麼 <code>exampleFunc()</code> 的輸出是？</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar</span><br><span class="line">exampleFunc()  <span class="comment">// console: global, false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Then, we update the function `foo.bar`</span></span><br><span class="line">foo.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'yo'</span>) &#125;</span><br><span class="line">foo.bar()  <span class="comment">// console: 'yo'</span></span><br><span class="line">exampleFunc()  <span class="comment">// console: ???</span></span><br></pre></td></tr></table></figure>  <details>      <summary>Answer</summary>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// console: global, false</span><br><span class="line">Reason:</span><br><span class="line">In the line ```var exampleFunc = foo.bar```,</span><br><span class="line">`example` got a copy of address of the function `foo.bar`.</span><br><span class="line">So that it won&apos;t be affected after `foo.bar` is updated.</span><br></pre></td></tr></table></figure>  </details></li><li><p>補充 2: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" target="_blank" rel="noopener">Object.prototype.constructor | MDN</a></p></li></ul><h2 id="reference-type"><a class="header-anchor" href="#reference-type"></a>Reference type</h2><p><em>Spoiler: 本段可用來解釋上一段中 <code>foo()</code> 與 <code>foo.prototype.constructor()</code> 輸出結果不同的原因</em><br><em>Note: 這邊的 <code>Reference</code> 是對於 object 與其所在 scope 的描述，與 <code>pass by value / reference</code> 中的 <code>reference</code> 講的不是一樣的概念</em></p><p><code>Reference</code> type 可以用以下的虛擬程式碼來表示（當作一個物件來看待時）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</span><br><span class="line">  base: <span class="xml"><span class="tag">&lt;<span class="name">base</span> <span class="attr">object</span>&gt;</span>,  // base object of this object belongs</span></span><br><span class="line">  propertyName: &lt;property name&gt;,  // name of this object</span><br><span class="line">  // strict: &lt;boolean&gt;,  // added in ES5, it will be `true` when `strict mode` is enabled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>Reference</code> type 的值只會有兩種：<br>1. <code>identifier</code> (variable names, function names, names of function arguments and names of <em>unqualified properties</em>* of the global object; see also <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="noopener">Chapter 4. Scope chain</a>)<br>2. <code>property accessor</code></p><p>* unqualified properties: (待確認) 所謂的 <code>qualified property</code> 是指一個 <strong>可以被設定的 (configurable)</strong> 屬性。所以 <code>unqualified property</code> 也就是無法被設定的屬性。但是在這要注意，原文強調的是 <em>unqualified properties of the global object</em> ，所以可能表示：</p><pre><code>只有在隸屬於 global object 的 `unqualified property` 才可以被當作 `identifier`</code></pre><p>參考: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Delete_in_strict_mode#What_went_wrong" target="_blank" rel="noopener">Delete in strict mode | MDN</a></p><hr><p>所謂的 <code>identifier</code> ，以下列位於 global scope 底下的變數與函數為例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其在 <strong>操作的過程中</strong> (原文: intermediate results of operations) ，會被解析成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">  base: global,</span><br><span class="line">  propertyName: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而當我們要從這些 <code>Reference</code> type 取得那些物件的實際值時，我們會透過一個像是以下虛擬程式碼的一個方法 <code>GetValue</code> 來達成：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// see also: ES3 sepcification - 8.7.1 GetValue</span></span><br><span class="line"><span class="comment">// https://www-archive.mozilla.org/js/language/E262-3.pdf</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Type(value) != Reference) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> base = GetBase(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we can tell the cause of `ReferenceError` and `TypeError` by this?</span></span><br><span class="line">    <span class="comment">// - TypeError: a is undefined (e.g. `var a; a.b`)</span></span><br><span class="line">    <span class="comment">// - ReferenceError: a is not defined (e.g. `a`)</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `[[Get]]`: returns the real value of object’s property, including as well</span></span><br><span class="line">  <span class="comment">// analysis of the inherited properties from a prototype chain</span></span><br><span class="line">  <span class="keyword">return</span> base.[[Get]](GetPropertyName(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>property accessor</code> ，也就是物件的屬性存取子，如下所示</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">foo.a  <span class="comment">// &lt;- `a` is a property accessor of object `foo`</span></span><br><span class="line">foo[<span class="string">'a'</span>]  <span class="comment">// &lt;- `a` is a property accessor of object `foo`</span></span><br></pre></td></tr></table></figure><hr><p>而我們要如何決定一個 function context 內所使用到的 <code>this</code> 指的是誰呢？基本上我們可以照著以下的規則來決定：</p><blockquote><p>The value of <code>this</code> in a function context is provided <strong>by the caller and determined by the current form of a call expression</strong>* (how the function call is written syntactically).</p></blockquote><h6 id="anchor-call-parentheses" style="visibility:hidden;"></h6><blockquote><p>If on the left hand side from the call parentheses <code>( ... )</code>** , there is a value of <code>Reference</code> type then <code>this</code> value is set to the <em>base object</em> of this value of <code>Reference</code> type.</p></blockquote><blockquote><p>In all other cases (i.e. with any other value type which is distinct from the <code>Reference</code> type), <code>this</code> value is always set to <code>null</code>. But since there is no any sense in <code>null</code> for <code>this</code> value, it is <em>implicitly</em> converted to <em>global object</em>.</p></blockquote><p>* 其實就是前面原文有提到的: <em>And the value of this is determined by the form of a call expression (in other words by the form how syntactically the function is called).</em></p><p>** 也就是呼叫函數時的那個表示式中最後的那兩個小括弧</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo()</span><br><span class="line"><span class="comment">// ↑ this</span></span><br></pre></td></tr></table></figure><p>所以綜合上述規則，最白話的講法就是：<br>先看函數呼叫的那段表示式中，函數的前面長什麼樣子：<br>1. 如果是 <code>a.b.func()</code> ，那麼 <code>this</code> 指的就是 <code>a.b</code> 的 <code>Reference</code> type 中的 <code>base</code> object<br>2. 如果是 <code>func()</code> ，那麼 <code>this</code> 則為 <code>null</code>。（但會根據 runtime 的不同而有不一樣的預設值，像是在 node.js 中為 <code>global</code> ，瀏覽器中為 <code>Window</code>）</p><p>再以原文中的三個例子來看，就可以知道為何 <code>this</code> 會是那樣的值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- example 01 ---</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reference` type of `foo`:</span></span><br><span class="line"><span class="comment">// var fooReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: global,</span></span><br><span class="line"><span class="comment">//   propertyName: 'foo'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">foo()  <span class="comment">// console: global</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- example 02 ---</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reference` type of `foo.bar`:</span></span><br><span class="line"><span class="comment">// var fooBarReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: foo,</span></span><br><span class="line"><span class="comment">//   propertyName: 'bar'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">foo.bar()  <span class="comment">// console: foo</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- example 03 ---</span></span><br><span class="line"><span class="keyword">var</span> test = foo.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Reference` type of `test`:</span></span><br><span class="line"><span class="comment">// var fooReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: global,</span></span><br><span class="line"><span class="comment">//   propertyName: 'test'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">test()  <span class="comment">// console: global</span></span><br></pre></td></tr></table></figure><p>回到上一段（<code>this</code> value in the function code）的例子，我們也就可以知道為何 <code>foo.prototype.constructor()</code> 會印出 <code>foo.prototype</code> 了，因為其 <code>Reference</code> type 為：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</span><br><span class="line">  base: foo.prototype,</span><br><span class="line">  propertyName: <span class="string">'constructor'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>因此，我們也可以利用 <code>this</code> 的這些機制，達成以下的功能：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = &#123;<span class="attr">bar</span>: <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> y = &#123;<span class="attr">bar</span>: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind `foo` to the property `test` of each object</span></span><br><span class="line">x.test = foo</span><br><span class="line">y.test = foo</span><br><span class="line"></span><br><span class="line">x.test() <span class="comment">// 10</span></span><br><span class="line">y.test() <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>而這樣的機制，也可以幫助我們做出類似 <code>Vue.js</code> 中所謂的 <code>computed property</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aBagOfSand = &#123;</span><br><span class="line">  weight: <span class="number">1500</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeightInGram</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`weight: <span class="subst">$&#123;<span class="keyword">this</span>.weight&#125;</span> (g)`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWeightInKilogram</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`weight: <span class="subst">$&#123;<span class="keyword">this</span>.weight<span class="regexp">/1000&#125; (kg)`)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">&#125;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInGram = getWeightInGram</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInKilogram = getWeightInKilogram</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp"></span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInGram()  /</span><span class="regexp">/ console: weight: 1500 (g)</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">aBagOfSand.weightInKilogram()  /</span><span class="regexp">/ console: weight: 1.5 (kg)</span></span></span></span><br></pre></td></tr></table></figure><h2 id="function-call-and-non-reference-type"><a class="header-anchor" href="#function-call-and-non-reference-type"></a>Function call and non-Reference type</h2><p>看完上述關於 <code>Reference</code> type 的內容後，可以發現提到的都是一般的<a href="#section-this-value-in-function-call-quote-2">函數呼叫情況（… in a usual function call …）</a>。</p><p>那麼是否代表有所謂 <strong>非一般的函數呼叫</strong> 呢？<br>其實就是指在 <a href="#anchor-call-parentheses"><code>call parentheses ( ... )</code></a> 的左側不是 <a href="#reference-type"><code>Reference</code> type</a> 的情況，如下範例所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;)()  <span class="comment">// output_1: ???</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Other complex exmaples</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.bar()  <span class="comment">// output_2: ???</span></span><br><span class="line">(foo.bar)()  <span class="comment">// output_3: ???</span></span><br><span class="line"></span><br><span class="line">(foo.bar = foo.bar)()  <span class="comment">// output_4: ???</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)()  <span class="comment">// output_5: ???</span></span><br><span class="line">(foo.bar, foo.bar)()  <span class="comment">// output_6: ???</span></span><br></pre></td></tr></table></figure><details><summary><span style="color: green; font-weight: bold">Click me to reveal the answer!</span></summary><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output_1: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line"></span><br><span class="line">output_2: `foo` object</span><br><span class="line">left hand side: `Reference` type</span><br><span class="line"></span><br><span class="line">output_3: `foo` object</span><br><span class="line">left hand side: `Reference` type</span><br><span class="line">Although there is a `grouping operator`* (the parentheses at the both sides of `foo.bar`), it was&apos;t applied.</span><br><span class="line">- steps:</span><br><span class="line">  1. (foo.bar)()</span><br><span class="line">     &lt;-------&gt; Returned value of this expression `(foo.bar)` is `foo.bar`, which is still a `Reference` type</span><br><span class="line">  2. foo.bar()</span><br><span class="line">     &lt;-------&gt; Then, this expression is evaluated</span><br><span class="line"></span><br><span class="line">output_4: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line">Inside the parentheses, there is a expression with `assignment operator` which will return a value**.</span><br><span class="line"></span><br><span class="line">output_5: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line">- steps:</span><br><span class="line">  1. (false || foo.bar)()</span><br><span class="line">     &lt;----------------&gt; Processing this expression (`logical OR`)</span><br><span class="line">  2. (false || foo.bar)</span><br><span class="line">      &lt;---&gt; result of condition is `false`, so that we continue to check the next condition</span><br><span class="line">  3. (false || foo.bar)</span><br><span class="line">               &lt;-----&gt; result of condition is not `false` / `null` / `undefined`, so that returned value will be: `function foo.bar()`</span><br><span class="line">  4. [function foo.bar()]()</span><br><span class="line">     &lt;------------------&gt; this is a `function` object, not a `Reference` type</span><br><span class="line"></span><br><span class="line">output_6: global</span><br><span class="line">left hand side: `function` object</span><br><span class="line">- steps:</span><br><span class="line">  1. (foo.bar, foo.bar)()</span><br><span class="line">     &lt;----------------&gt; Processing this expression (`comma operator`)</span><br><span class="line">  2. (foo.bar, foo.bar)</span><br><span class="line">      &lt;-----&gt; this value is evaluated, but not returned</span><br><span class="line">  3. (foo.bar, foo.bar)</span><br><span class="line">               &lt;-----&gt; this value is evaluated and returned, so that the returned value of this expression is: `function foo.bar()`</span><br><span class="line">  4. [function foo.bar()]()</span><br><span class="line">     &lt;------------------&gt; this is a `function` object, not a `Reference` type</span><br></pre></td></tr></table></figure><p>* <code>grouping operator</code>: which accepts <code>expression</code> only<br>** in a console, entering the following content line by line, you will see the following result:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> a        <span class="comment">// this is a statement</span></span><br><span class="line"><span class="literal">undefined</span>  <span class="comment">// returned value of this statement</span></span><br><span class="line"></span><br><span class="line">&gt; a = <span class="number">1</span>        <span class="comment">// this is an expression</span></span><br><span class="line"><span class="number">1</span>          <span class="comment">// returned value of this expression</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// so that...</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// statement</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">&gt; a = foo            <span class="comment">// expression</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)   // <span class="title">got</span> <span class="title">a</span> <span class="title">returned</span> <span class="title">value</span>: `<span class="title">function</span>` <span class="title">object</span></span></span><br></pre></td></tr></table></figure><ul><li>補充1: <a href="https://2ality.com/2012/09/expressions-vs-statements.html" target="_blank" rel="noopener">expression versus statements in JavaScript</a></li><li>補充2: 關於上方連結中 <code>3.1 Object literal versus block</code> 提到的東西，可以再看看這個應用 <a href="http://www.jsfuck.com/" target="_blank" rel="noopener">JSFuck</a></li></ul></details><h2 id="reference-type-and-null-this-value"><a class="header-anchor" href="#reference-type-and-null-this-value"></a>Reference type and null this value</h2><p>除了上一段所提到的其他種 function call 與其相對應的 <code>this</code> 值，我們還有一些情況需要理解。<br>本段以說明那些 <code>this</code> 應該要被設為 null (也就是說最後會變成 global (node.js) 或 Window (browser)) 的情況：</p><ol><li>Calling an unbound function in a closure:</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// console: global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Because:</span></span><br><span class="line"><span class="comment">// var barReference = &#123;</span></span><br><span class="line"><span class="comment">//   base: AO,  // (note*) activated object, which return `this` as null, because `AO.__parent__` is null (or in default value: `global`)</span></span><br><span class="line"><span class="comment">//   propertyName: 'bar'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>* Which might be true only in some implementation of Javascript, e.g. <code>SpiderMonkey</code>, <code>Rhino</code>. See also <a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="noopener">this chapter</a></p><ol start="2"><li>In a <code>with</code> statement:</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (&#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">  &#125;,</span><br><span class="line">  x: <span class="number">20</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  foo()  <span class="comment">// console: 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Because:</span></span><br><span class="line"><span class="comment">// var fooReference = &#123;</span></span><br><span class="line"><span class="comment">//  base: __withObject,</span></span><br><span class="line"><span class="comment">//  propertyBane: 'foo'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>這部份需要注意到，此時的 <code>foo</code> 裡面的 <code>this</code> 指向的是一個 <code>__withObject</code> 而非 <code>global</code>，因此印出的 <code>this.x</code> 是 <code>with</code> statement 裡面定義的 <code>x</code> 而非 global scope 中的 <code>x</code>。</p><p>而範例則是在說明使用 <code>with</code> 時會造成的影響，關於 <code>with</code> 的效果，除了原文所述：</p><blockquote><p>The <code>with</code> statement adds its object in front of <a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/#affecting-on-scope-chain-during-code-execution" target="_blank" rel="noopener">scope chain</a> i.e. <em>before</em> the activation object. Accordingly, having values of type <code>Reference</code> (by the identifier or a property accessor) we have base object not as an activation object but object of a <code>with</code> statement.</p></blockquote><p>會有這樣的結果是因為在我們使用 <code>with</code> 時，會將 <code>with</code> 裡面定義的物件加到 scope chain 的前面，使得在執行階段時會優先搜尋到 <code>with</code> 內定義的物件，這部分的說明在原文（見下方）和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener">MDN</a> 上也有敘述。</p><blockquote><p>By the way, it relates not only to inner, but also to global functions because the <code>with</code> object <em>shadows</em>* higher object (global or an activation object) of the scope chain</p></blockquote><p>* 因為 <code>with</code> 內的物件會被優先搜索到，導致更上層 scope 中的物件會相對地被 <em>遮蓋掉</em>（對應到原文中的 <code>shadows</code>）</p><ol start="3"><li>In a <code>try ... catch ...</code> statement</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e()  <span class="comment">// console: __catchObject - in ES3, global - fixed in ES5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// on idea (in normal case, implmented in ES3)</span></span><br><span class="line"><span class="comment">// var eReference = &#123;</span></span><br><span class="line"><span class="comment">//  base: __catchObject,</span></span><br><span class="line"><span class="comment">//  propertyName: 'e'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In ES5 (the implementation above is regarded as a bug, so that `this` value is forced to be `global`)</span></span><br><span class="line"><span class="comment">// var eReference = &#123;</span></span><br><span class="line"><span class="comment">//  base: global,</span></span><br><span class="line"><span class="comment">//  propertyName: 'e'</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>而關於 <code>catch</code> 在 ES3 和 ES5 中實作的差異，請見下方：</p><ul><li><p><a href="https://www-archive.mozilla.org/js/language/E262-3.pdf" target="_blank" rel="noopener"><code>catch</code> block in ES3 specification</a>:</p><blockquote><p>The production <em>Catch</em>: <code>catch</code> (*Identifier) <em>Block</em> is evaluated as follows:</p><ol><li>Let <em>C</em> be the parameter that has been passed to this production.</li><li>Create a new object as if by the expression <code>new Object()</code>.</li><li>Create a property in the object Result(2). The property’s name is <em>Identifier</em>, value is <em>C</em>.value, and attributes are { DontDelete }.</li><li>Add Result(2) to the front of the scope chain.</li><li>Evaluate <em>Block</em>.</li><li>Remove Result(2) from the front of the scope chain.</li><li>Return Result(5).</li></ol></blockquote><p>我們可以看到在步驟 1~3 中，有一個新物件被建立出來且加上了一個 property 叫作 <em>Identifier</em>，而其值為一開始被傳入 <code>catch</code> 區塊中的參數。<br>而第 4 步是一個關鍵：這時會將步驟 2 建立出的物件放到目前 scope chain 的<strong>前面</strong>。這也是為什麼在上述例子中，ES3 中 <code>eReference</code> 的 base 會是一個 <code>__catchObject</code>。<br>而 <code>catch</code> 區塊的特性：「內部的物件只會存在這個區塊中，當執行流程離開後，便無法再次取得內部的物件」這部份則是透過步驟 6 來達成（移除掉剛剛加到 scope chain 前面的物件）。</p><p>（題外話：看到這邊，其實可以發現在 ES3 spec 內就已經有所謂 <code>block</code> 的用詞。只是這個 <code>block</code> 和 ES6 導入的 <code>block scope</code> 有什麼關聯呢？之後再來研究看看好了）</p></li><li><p><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-12.14" target="_blank" rel="noopener"><code>catch</code> block in ES5 specification</a>:</p><blockquote><p>The production <em>Catch</em>: <code>catch</code> (*Identifier) <em>Block</em> is evaluated as follows:</p><ol><li>Let <em>C</em> be the parameter that has been passed to this production.</li><li>Let <em>oldEnv</em> be the running execution context’s <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener">LexicalEnvironment</a>.</li><li>Let <em>catchEnv</em> be the result of calling <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2.2.2" target="_blank" rel="noopener">NewDeclarativeEnvironment</a> passing <em>oldEnv</em> as the argument.</li><li>Call the <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.2" target="_blank" rel="noopener">CreateMutableBinding</a> concrete method of <em>catchEnv</em> passing the <em>Identifier</em> String value as the argument.</li><li>Call the <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.2.1.1.3" target="_blank" rel="noopener">SetMutableBinding</a> concrete method of <em>catchEnv</em> passing the <em>Identifier</em>, <em>C</em>, and <strong>false</strong> as arguments. Note that the last argument is immaterial in this situation.</li><li>Set the running execution context’s <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener">LexicalEnvironment</a> to <em>catchEnv</em>.</li><li>Let <em>B</em> be the result of evaluating Block.</li><li>Set the running execution context’s <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener">LexicalEnvironment</a> to <em>oldEnv</em>.</li><li>Return <em>B</em>.</li></ol></blockquote><p>在 ES5 中，步驟 1 與 ES3 的作法一樣，但是後續有了一些改變。這邊先簡述為何在 ES5 中，<code>eReference</code> 的 base 會變成 <code>global</code>：<br>因為在步驟 6 中會將目前正在執行的 execution context 的 <code>Lexical environment</code> 設定為 <em>catchEnv</em> （為了 <code>catch</code> 區塊而新建的 <code>Lexical environment</code>） 的 execution context ，所以 <code>catch</code> 區塊可以視為原本的 execution context 的延伸，也因此 <code>eReference</code> 的 base 會指向 <code>global</code>。</p></li></ul><ol start="4"><li>In a recusive function call</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  !bar &amp;&amp; foo(<span class="number">1</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// console:</span></span><br><span class="line"><span class="comment">// global  // the first time</span></span><br><span class="line"><span class="comment">// global  // the second time</span></span><br></pre></td></tr></table></figure><blockquote><p>At the first call of function, base object is the parent activation object (or the global object), at the recursive call — base object should be special object storing the optional name of a function expression.<br>However, in this case <code>this</code> value is also always set to global</p></blockquote><p>若依照一般的執行流程來判斷，第二次印出的結果應該要是一個物件，但是這邊卻會被設定為 <code>global</code> （而這樣才是正確的）。</p><h2 id="this-value-in-function-called-as-the-constructor"><a class="header-anchor" href="#this-value-in-function-called-as-the-constructor"></a>This value in function called as the constructor</h2><p>再來看一個例子，當我們把一個 function 當作物件的 constructor 時：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();  <span class="comment">// console: 1st line: &#123;&#125;; 2nd line: &#123;x: 10&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x);  <span class="comment">// console: 10</span></span><br></pre></td></tr></table></figure><p>關於 <code>new</code> 關鍵字，可見 ES3 specification - 11.2.2：</p><blockquote><p>The production <em>NewExpression</em>: <strong>new</strong> <em>NewExpression</em> is evaluated as follows:</p><ol><li>Evaluate <em>NewExpression</em>.</li><li>Call GetValue(Result(1)).</li><li>If Type(Result(2)) is not Object, throw a <strong>TypeError</strong> exception.</li><li>If Result(2) does not implement the internal <strong>[[Construct]]</strong> method, throw a <strong>TypeError</strong> exception.</li><li>Call the [[Construct]] method on Result(2), providing no arguments (that is, an empty list of arguments).</li><li>Return Result(5).</li></ol></blockquote><p>而關於 <code>this</code> 被綁定到新建立物件的原因在第 4 步驟中呼叫的 <strong>[[Construct]]</strong>，我們把它在 ES3 sepcification 的內容翻出來看：</p><blockquote><p><strong>13.2.2 [[Construct]]</strong><br>When the [[Construct]] property for a Function object <em>F</em> is called, the following steps are taken:</p><ol><li>Create a new native ECMAScript object</li><li>Set the [[Class]] property of Result(1) to <strong>&quot;Object&quot;</strong></li><li>Get the value of the <strong>prototype</strong> property if the F</li><li>If Result(3) is an object, set the [[Prototype]] property of Result(1) to Result(3).</li><li>If Result(3) is not an object, set the [[Prototype]] property of Result(1) to the original Object prototype object as described in section 15.2.3.1.</li><li>Invoke the [[Call]] property of <em>F</em>, providing Result(1) as the <strong>this</strong> value and providing the argument list passed into [[Construct]] as the argument values.</li><li>If Type(Result(6)) is Object then return Result(6).</li><li>Return Result(1).</li></ol></blockquote><p>關鍵就在於上方的步驟 6 ：在呼叫 <em>F</em>.[[call]] 時，會將第 1 步產生的結果（即一個新的 <code>ECMAScript object</code>）設定為 <code>this</code> 的值並將其他傳進這個 <code>[[Construct]]</code> 的參數列表當作呼叫 <em>F</em>.[[Call]] 的參數值。<br>所以如果要用更簡化的方式來解讀這些步驟的話，就如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">MDN 上關於 <code>new</code> 關鍵字的說明</a>：</p><blockquote><ol><li>Creates a blank, plain JavaScript object</li><li>Links (sets the constructor of) this object to another object</li><li>Passes the newly created object from Step 1 as the this context</li><li>Returns <code>this</code> if the function doesn’t return its own object</li></ol></blockquote><p>這也就是為什麼在上述例子中，使用 <code>new</code> 建立一個 <code>a</code> 物件時，會先後分別看到 <code>{}</code> 與 <code>{x: 10}</code>，然後在 <code>console.log(a.x)</code> 時，可以印出 <code>10</code>。</p><h2 id="manual-setting-of-this-value-for-a-function-call"><a class="header-anchor" href="#manual-setting-of-this-value-for-a-function-call"></a>Manual setting of <code>this</code> value for a function call</h2><p>如果要在 call function 時手動設定 <code>this</code> 的話可以使用 <code>apply</code>, <code>call</code> 這兩個方法 (ES5.1 開始支援另一個新的方法 <code>bind</code>，但是並不是用於呼叫函數時的動態綁定，因此這邊暫時不討論)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.b)</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(<span class="number">20</span>)  <span class="comment">// console: 10, 20  (because `this` === global)</span></span><br><span class="line"></span><br><span class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>)  <span class="comment">// console: 20, 30 (because `this` === &#123;b: 20&#125;)</span></span><br><span class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>])  <span class="comment">// console: 30, 40 (because `this` === &#123;b: 30&#125;)</span></span><br></pre></td></tr></table></figure><p><code>call</code> 與 <code>apply</code> 的第一個參數都是接受一個物件當為綁定的對象，而差別只在於後續的參數給予方式：<br>- <code>call</code> 接受的是一連串的參數，如 <code>a.call(obj, arg1, arg2, ...)</code><br>- <code>apply</code> 接受的是參數陣列，如 <code>a.apply(obj, [arg1, arg2, ...])</code></p><p>參考： <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener"><code>Function.prototype.call</code></a>, <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" target="_blank" rel="noopener"><code>Function.prototype.apply</code></a></p><h2 id="conclusion"><a class="header-anchor" href="#conclusion"></a>Conclusion</h2><p><code>this</code> 在 ECMAScript 的底層設計上看起來很複雜，但從我們實作的角度來看，要知道 <code>this</code> 的值其實不會很難。<br>基本上從 <a href="#section-this-value-in-function-call-quote-2">函數的呼叫形式</a> 就可以推算出來，只是要再考慮到其他如 <a href="#function-call-and-non-reference-type">Function call and non-Reference type</a> 和 <a href="#reference-type-and-null-this-value">Reference type and null this value</a> … 等比較特殊的情況而已。</p><p>當然，透過直接探索 ECMAScript specification 也能夠幫助我們更了解 <code>this</code> 的概念，像是：為什麼在我們使用 <code>new</code> 建立新物件時， <code>this</code> 的值會被自動綁定到新物件上。雖然 MDN 也有詳細的說明，但是相信對於希望能更了解根本原因的人，ECMAScript specification 絕對是個很適合的<s>休閒讀物</s>參考書！</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
