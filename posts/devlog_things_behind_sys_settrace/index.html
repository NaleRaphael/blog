<!DOCTYPE html>
<html lang=en>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="As I was digging into CPython’s internals in order to implement a new feature of a virtual machine made recently, I guess that I probably solved a TODO task listed in the source code of byterun to a c">
<meta name="keywords" content="devlog,python">
<meta property="og:type" content="article">
<meta property="og:title" content="Things behind `sys.settrace()`">
<meta property="og:url" content="https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/index.html">
<meta property="og:site_name" content="Little things matter">
<meta property="og:description" content="As I was digging into CPython’s internals in order to implement a new feature of a virtual machine made recently, I guess that I probably solved a TODO task listed in the source code of byterun to a c">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-03-23T01:46:38.207Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Things behind `sys.settrace()`">
<meta name="twitter:description" content="As I was digging into CPython’s internals in order to implement a new feature of a virtual machine made recently, I guess that I probably solved a TODO task listed in the source code of byterun to a c">
    
    
        
          
              <link rel="shortcut icon" href="/blog/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/blog/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon.png">
          
        
    
    <!-- google site verification -->
    
    <meta name="google-site-verification" content="csFkwHyknLPxNjkvXl2VnRGqRUpMd4-NFd49LnpCtSg">
    
    <!-- title -->
    <title>Things behind `sys.settrace()`</title>
    <!-- styles -->
    <link rel="stylesheet" href="/blog/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/blog/css/rtl.css">
    
    <!-- rss -->
    
    
</head>


<body class="max-width mx-left px3 ltr">

    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/about/">About</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="/blog/tags/">tags</a></li>
         
          <li><a href="/blog/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/blog/posts/devlog_import_a_package_dynamically/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/blog/posts/devlog_create_a_builtin_frame_object/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&text=Things behind `sys.settrace()`"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&is_video=false&description=Things behind `sys.settrace()`"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Things behind `sys.settrace()`&body=Check out this article: https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&name=Things behind `sys.settrace()`&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#when-you-call-pdb-set-trace"><span class="toc-number">1.</span> <span class="toc-text">When you call pdb.set_trace()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#take-a-look-at-the-huge-evaluation-loop"><span class="toc-number">2.</span> <span class="toc-text">Take a look at the huge evaluation loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#so-how-would-pdb-work-with-line-tracing"><span class="toc-number">3.</span> <span class="toc-text">So, how would pdb work with line tracing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in-bytefall"><span class="toc-number">4.</span> <span class="toc-text">In bytefall…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#further-reading"><span class="toc-number">5.</span> <span class="toc-text">Further reading</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Things behind `sys.settrace()`
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">naleraphael</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-03-12T03:20:08.000Z" itemprop="datePublished">2020-03-12</time>
        
        (Updated: <time datetime="2020-03-23T01:46:38.207Z" itemprop="dateModified">2020-03-23</time>)
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/blog/tags/devlog/">devlog</a>, <a class="tag-link" href="/blog/tags/python/">python</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>As I was digging into CPython’s internals in order to implement a new feature of a virtual machine made recently, I guess that I probably solved a <a href="https://github.com/nedbat/byterun/blob/62f9b1a9c85f52c28b78cc8942243c5c962b1954/byterun/pyvm2.py#L325-L327" target="_blank" rel="noopener">TODO task listed in the source code of <code>byterun</code></a> to a certain degree.</p>
<p>This story begins with an interesting idea of using <code>pdb</code> in <code>bytefall</code> virtual machine…</p>
<p>(To avoid confusion and being affected by the changes among versions, here we take CPython 3.7 as the runtime)</p>
<h2 id="when-you-call-pdb-set-trace"><a class="header-anchor" href="#when-you-call-pdb-set-trace"></a>When you call <code>pdb.set_trace()</code></h2>
<p>Typically, you need the following line to enter the debugging mode provided by <code>pdb</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure>
<p>Once that line is executed, you are able to use all commands provide by <code>pdb</code> or have a good time with REPL inside the interactive mode. However, in prior versions of <code>bytefall</code>, internal execution flow of <code>bytefall</code> virtual machine will be revealed when debugging mode is activated.</p>
<p>It’s such a tsunami for users who just want to check how their code work. Because they will not only be overwhelmed by too much information, but also get stucked in those frames with data related to their code indirectly.</p>
<p>So, our goal is to make user able to use <code>pdb</code> like the way they are using in a normal Python runtime. To achieve this goal, we have to understand how <code>pdb.set_trace()</code> work first. But before diving into source code, we need to figure out what we are interesting in, and it will help us focus on the problem we want to solve.</p>
<p><a name="goal_of_tracing_pdb_source"></a></p>
<p>As we want to control the information exposure of internal execution, what we need to trace are most likely some operations related to <code>frame</code>. Because <code>frame</code> contains information of executing scope, and it also related to the call stack which we can get from <code>traceback</code>.</p>
<p>It sounds like a reasonable guess, so let’s start to take a quick look at the implementation of <code>pdb</code>.</p>
<ol>
<li>
<p>Starting from the call <code>pdb.set_trace()</code>, we can speculate that <code>set_trace</code> is a function defined in the module scope of <code>pdb</code>. And here is what we got in <code>pdb.py</code>:</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @pdb.py::set_trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_trace</span><span class="params">(*, header=None)</span>:</span></span><br><span class="line">    pdb = Pdb()</span><br><span class="line">    <span class="keyword">if</span> header <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Print `header` to stdout</span></span><br><span class="line">        pdb.message(header)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The code we want to know</span></span><br><span class="line">    pdb.set_trace(sys._getframe().f_back)</span><br></pre></td></tr></table></figure>
<p>In those lines above, we know that there is an instance of <code>Pdb</code> class being instantiated and its method <code>set_trace()</code> is called.<br>
Also, <code>set_trace()</code> is the only operation related to frame here, so that it’s what we are interesting in. However, we cannot find <code>set_trace()</code> in <code>Pdb</code> class, so it’s probably defined in its parent <code>bdb.Bdb</code>.</p>
</li>
<li>
<p>After navigating to the file <code>bdb.py</code>, we found it indeed:</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @bdb.py::class Bdb::set_trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_trace</span><span class="params">(self, frame=None)</span>:</span></span><br><span class="line">    <span class="string">"""Start debugging from frame.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If frame is not specified, debugging starts from caller's frame.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        frame = sys._getframe().f_back</span><br><span class="line">    self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Install callback `trace_dispatch` to each frame, and set `botframe` up</span></span><br><span class="line">    <span class="keyword">while</span> frame:</span><br><span class="line">        frame.f_trace = self.trace_dispatch</span><br><span class="line">        self.botframe = frame</span><br><span class="line">        frame = frame.f_back</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set information for `step` command</span></span><br><span class="line">    self.set_step()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The code we want to know</span></span><br><span class="line">    sys.settrace(self.trace_dispatch)</span><br></pre></td></tr></table></figure>
<p>According to the documentation of <a href="https://docs.python.org/3/library/inspect.html#types-and-members" target="_blank" rel="noopener">inspect</a> and <a href="https://docs.python.org/3/library/sys.html#sys.settrace" target="_blank" rel="noopener">sys</a>, we can know that <code>f_trace</code> is used to store a callback function for tracing code, and that callback function will be installed through <code>sys.settrace()</code>.</p>
<p>And what will the callback function <code>trace_dispatch()</code> do?</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace_dispatch</span><span class="params">(self, frame, event, arg)</span>:</span></span><br><span class="line">    <span class="comment"># Details about this callback function is also documented in its</span></span><br><span class="line">    <span class="comment"># docstring.</span></span><br><span class="line">    <span class="keyword">if</span> self.quitting:</span><br><span class="line">        <span class="keyword">return</span> <span class="comment"># None</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'line'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_line(frame)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'call'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_call(frame, arg)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'return'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_return(frame, arg)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'exception'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dispatch_exception(frame, arg)</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'c_call'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.trace_dispatch</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'c_exception'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.trace_dispatch</span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'c_return'</span>:</span><br><span class="line">        <span class="keyword">return</span> self.trace_dispatch</span><br><span class="line">    print(<span class="string">'bdb.Bdb.dispatch: unknown debugging event:'</span>, repr(event))</span><br><span class="line">    <span class="keyword">return</span> self.trace_dispatch</span><br></pre></td></tr></table></figure>
<p>It works like the way how it’s described in document. When it’s invoked with argument <code>event</code> of <code>'line', 'call', 'return', 'exception'</code>, it will call those functions corresponding to each event. But it’s irrelevant to the control of frame stack. In other word, it’s like a subscriber who is responsible to do something according to given <code>frame</code>, not an issuer which is able to determine when to fire an event with specific <code>frame</code>. Therefore, it seems <code>trace_dispatch()</code> is not a function able to control the information exposure of internal execution.</p>
<p>But it’s fine, let’s keep tracing deeper into <code>sys.settrace()</code>.</p>
</li>
<li>
<p>Since <code>sys</code> module is not written in Python, we have to access it from CPython source code. And here is how <code>sys.settrace()</code> looks like:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/sysmodule.c::sys_settrace</span></span><br><span class="line"><span class="comment">// signature in Python:</span></span><br><span class="line"><span class="comment">//   `settrace(function)`</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">sys_settrace(PyObject *self, PyObject *args) &#123;</span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == Py_None)</span><br><span class="line">        PyEval_SetTrace(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// args: your Python callback function</span></span><br><span class="line">        PyEval_SetTrace(trace_trampoline, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>According to the signature of <code>sys.settrace()</code>, we can know that <code>args</code> is the callback function passed from Python side. And once <code>args</code> is not <code>None</code>, <code>PyEval_SetTrace()</code> will be called with a function named <code>trace_trampoline()</code> and the callback function we just passed in.</p>
<p>Next, let’s see how <code>trace_trampoline()</code> is implemented.</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/sysmodule.c::trace_trampoline</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">trace_trampoline(PyObject *self, PyFrameObject *frame,</span><br><span class="line">                 <span class="keyword">int</span> what, PyObject *arg) &#123;</span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine the callback function</span></span><br><span class="line">    <span class="keyword">if</span> (what == PyTrace_CALL)</span><br><span class="line">        callback = self;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        callback = frame-&gt;f_trace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    result = call_trampoline(callback, frame, what, arg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @cpython/Python/sysmodule.c::call_trampoline</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">call_trampoline(PyObject* callback,</span><br><span class="line">                PyFrameObject *frame, <span class="keyword">int</span> what, PyObject *arg) &#123;</span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">0</span>] = (PyObject *)frame;</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">1</span>] = whatstrings[what];</span><br><span class="line">    <span class="built_in">stack</span>[<span class="number">2</span>] = (arg != <span class="literal">NULL</span>) ? arg : Py_None;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* call the Python-level function */</span></span><br><span class="line">    result = _PyObject_FastCall(callback, <span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Remember what the signature of <code>trace_dispatch()</code> looks like? The last 3 arguments are the same as those in signatures of <code>trace_trampoline()</code> and <code>call_trampoline()</code>.<br>
So, based on these implementation and function signatures, we can speculate that <code>trace_trampoline()</code> would play a role of invoking callback function while it is triggered.</p>
<p>But still, these 2 C-functions are not used to control frame stack. There is one remaining function for us to keep investigating: <code>PyEval_SetTrace()</code>.</p>
</li>
<li>
<p>Prefix of <code>PyEval_SetTrace()</code> indicating that this function is related to the bytecode dispatching loop locating in <code>ceval.c</code>, and here is a sketch of it:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c::PyEval_SetTrace</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PyEval_SetTrace(Py_tracefunc func, PyObject *arg)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line"></span><br><span class="line">    tstate-&gt;c_tracefunc = func;</span><br><span class="line">    tstate-&gt;c_traceobj = arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* omitted code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can see that there are 2 attributes of <code>tstate</code> is set, and they are also the input arguments of this function. To make it clear, let’s recall the call stack starting from <code>sys.settrace()</code> in Python with a custom callback function named in <code>py_callback</code>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># --- In Python ---</span><br><span class="line">sys.settrace(py_callback)</span><br><span class="line"></span><br><span class="line"># --- In aspect of C ---</span><br><span class="line"># -&gt;</span><br><span class="line"># signature: `sys_settrace(PyObject *self, PyObject *args)`</span><br><span class="line">sys_settrace(..., py_callback)</span><br><span class="line"></span><br><span class="line"># -&gt;</span><br><span class="line"># signature: `PyEval_SetTrace(Py_tracefunc func, PyObject *arg)`</span><br><span class="line">PyEval_SetTrace(trace_trampoline, py_callback)</span><br></pre></td></tr></table></figure>
<p>Therefore, we can know that <code>func</code> and <code>arg</code> are actually:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in PyEval_SetTrace()</span></span><br><span class="line">tstate-&gt;c_tracefunc = func;     <span class="comment">// trace_trampoline</span></span><br><span class="line">tstate-&gt;c_traceobj = arg;       <span class="comment">// py_callback</span></span><br></pre></td></tr></table></figure>
<p>And we can be sure that <code>pdb.set_trace()</code> is just an operation of setting up things for tracing code, instead of an operation related to the control of frame stack. But since we got some clues about <code>tstate-&gt;c_tracefunc</code> and <code>tstate-&gt;c_traceobj</code>, we can still go further into the huge loop inside <code>_PyEval_EvalFrameDefault()</code>.</p>
</li>
</ol>
<h2 id="take-a-look-at-the-huge-evaluation-loop"><a class="header-anchor" href="#take-a-look-at-the-huge-evaluation-loop"></a>Take a look at the huge evaluation loop</h2>
<p>Before analyzing <code>_PyEval_EvalFrameDefault()</code>, we can find out those functions which take either <code>tstate-&gt;c_tracefunc</code> or <code>tstate-&gt;c_traceobj</code> as its arguments. This could make us focus on those parts which we are interested in.</p>
<p>And here are the signatures of those functions we found:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">call_trace_protected(Py_tracefunc func, PyObject *obj,</span><br><span class="line">                     PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">                     <span class="keyword">int</span> what, PyObject *arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">call_trace(Py_tracefunc func, PyObject *obj,</span><br><span class="line">           PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">           <span class="keyword">int</span> what, PyObject *arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">maybe_call_line_trace(Py_tracefunc func, PyObject *obj,</span><br><span class="line">                      PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">                      <span class="keyword">int</span> *instr_lb, <span class="keyword">int</span> *instr_ub, <span class="keyword">int</span> *instr_prev)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">call_exc_trace(Py_tracefunc func, PyObject *self,</span><br><span class="line">               PyThreadState *tstate, PyFrameObject *f)</span><br></pre></td></tr></table></figure>
<p>Bases on this, we can simplify the implementation of <code>_PyEval_EvalFrameDefault()</code> to the following one:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c::_PyEval_EvalFrameDefault</span></span><br><span class="line">_PyEval_EvalFrameDefault() &#123;</span><br><span class="line">    <span class="comment">/* 0. Definition of marcos */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. Push a new frame to stack, as entering a new code block. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. Invoke trace function with event: PyTrace_CALL  */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    call_trace_protected(..., PyTrace_CALL, ...)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. Loop for bytecode dispatch */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* 4. Invoke trace function with event: PyTrace_LINE */</span></span><br><span class="line">    fast_next_opcode:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        maybe_call_line_trace(..., PyTrace_LINE, ...)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. Dispatch opcode */</span></span><br><span class="line">    dispatch_opcode:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. Handle errors and invoke trace function with event: PyTrace_EXCEPTION */</span></span><br><span class="line">error:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        call_exc_trace(...)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. Handle the end of block, unwind remaining blocks */</span></span><br><span class="line">fast_block_end:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 8. Invoke trace function with event: PyTrace_RETURN */</span></span><br><span class="line">fast_yield:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    call_trace(..., PyTrace_RETURN, ...)  <span class="comment">// or `call_trace_protected()`</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 9. Pop frame from stack, as exiting a code block */</span></span><br><span class="line">exit_eval_frame:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With the simplified code above, we can roughly understand the execution flow of a CPython interpreter. Besides, timing of each trace event documented in <code>trace_dispatch()</code> is also found out now (those sections are marked at the code block above):</p>
<ul>
<li>‘call’: section_02, PyTrace_CALL</li>
<li>‘line’: section_03, PyTrace_LINE</li>
<li>‘exception’: section_06, PyTrace_EXCEPTION</li>
<li>‘return’: section_08, PyTrace_RETURN</li>
</ul>
<p>Therefore, answer of <a href="#goal_of_tracing_pdb_source">our guess mentioned in previous section</a> is revealed:</p>
<ol>
<li>Frame stack is not controlled by a single function, it related to the recursive execution of <code>_PyEval_EvalFrameDefault()</code>. (further reading: <a href="https://github.com/python/cpython/blob/39680fb7043e555469e08d3c4f49073acca77b20/Objects/call.c#L385-L440" target="_blank" rel="noopener">cpython/Objects/call.c</a>)</li>
<li>There is nothing like an event issuer, tracing events are issued after entering those execution blocks.</li>
</ol>
<h2 id="so-how-would-pdb-work-with-line-tracing"><a class="header-anchor" href="#so-how-would-pdb-work-with-line-tracing"></a>So, how would <code>pdb</code> work with line tracing</h2>
<p>There is an interesting function named <code>maybe_call_line_trace()</code>, and you can see that it will be invoked whenever there is a new <code>opcode</code> is going to be dispatched (see also <a href="https://github.com/python/cpython/blob/39680fb7043e555469e08d3c4f49073acca77b20/Python/ceval.c#L1022-L1025" target="_blank" rel="noopener">here</a>).</p>
<p>But we should note that there is a prefix <code>maybe</code>, which indicates that function actually won’t invoke a trace function everytime when it is executed. It does make sense, because what is going to be dispatched here is <strong>bytecode</strong>, rather than <strong>source code</strong> we written. And one line of source code usually can be compiled to multiple lines of bytecode.</p>
<p>Now, another question comes up: “How does it knows when to invoke trace function for line tracing since <code>maybe_call_line_trace()</code> locates inside a loop for dispatching bytecode?”<br>
It’s not a hard problem to be answered after checking out how it is implemented:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @cpython/Python/ceval.c::maybe_call_line_trace</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">maybe_call_line_trace(Py_tracefunc func, PyObject *obj,</span><br><span class="line">                      PyThreadState *tstate, PyFrameObject *frame,</span><br><span class="line">                      <span class="keyword">int</span> *instr_lb, <span class="keyword">int</span> *instr_ub, <span class="keyword">int</span> *instr_prev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> line = frame-&gt;f_lineno;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the last instruction executed isn't in the current</span></span><br><span class="line"><span class="comment">       instruction window, reset the window.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;f_lasti &lt; *instr_lb || frame-&gt;f_lasti &gt;= *instr_ub) &#123;</span><br><span class="line">        PyAddrPair bounds;</span><br><span class="line">        line = _PyCode_CheckLineNumber(frame-&gt;f_code, frame-&gt;f_lasti,</span><br><span class="line">                                       &amp;bounds);</span><br><span class="line">        *instr_lb = bounds.ap_lower;</span><br><span class="line">        *instr_ub = bounds.ap_upper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If the last instruction falls at the start of a line or if it</span></span><br><span class="line"><span class="comment">       represents a jump backwards, update the frame's line number and</span></span><br><span class="line"><span class="comment">       then call the trace function if we're tracing source lines.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((frame-&gt;f_lasti == *instr_lb || frame-&gt;f_lasti &lt; *instr_prev)) &#123;</span><br><span class="line">        frame-&gt;f_lineno = line;</span><br><span class="line">        <span class="keyword">if</span> (frame-&gt;f_trace_lines) &#123;</span><br><span class="line">            result = call_trace(func, obj, tstate, frame, PyTrace_LINE, Py_None);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Always emit an opcode event if we're tracing all opcodes. */</span></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;f_trace_opcodes) &#123;</span><br><span class="line">        result = call_trace(func, obj, tstate, frame, PyTrace_OPCODE, Py_None);</span><br><span class="line">    &#125;</span><br><span class="line">    *instr_prev = frame-&gt;f_lasti;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Clearly, we can know that:</p>
<ol>
<li>There is a function <code>_PyCode_CheckLineNumber()</code> which is used to find the upper and lower bound of index of bytecode instruction (denoted as <code>instr_lb</code> and <code>instr_ub</code>; further reading: <a href="https://github.com/python/cpython/blob/3.7/Objects/lnotab_notes.txt" target="_blank" rel="noopener">line number table</a>).</li>
<li><code>frame.f_lasti</code> is an index of the lastest executed bytecode instruction.</li>
<li>Just like the comment shown above: once we are just entering a new interval of bytecode instructions (<code>frame-&gt;f_lasti == *instr_lb</code>) or an operation of jumping backward has been executed (e.g. block of <code>for</code>/<code>while</code> loop), trace function will be invoked (of course, only when the flag <code>frame-&gt;f_trace_lines</code> is set).</li>
<li>If the flag <code>frame-&gt;f_trace_opcodes</code> is set, trace function will be invoked with an event argument <code>PyTrace_OPCODE</code>.</li>
</ol>
<p>Besides, we got a useful information from it:</p>
<blockquote>
<p>Line number of source code is evaluated only when it need to be used.</p>
</blockquote>
<p>Though that is not a topic of this article, it shows itself as a part of the reason why a Python script runs slower under a line tracing mode or profiling mode.</p>
<h2 id="in-bytefall"><a class="header-anchor" href="#in-bytefall"></a>In <code>bytefall</code>…</h2>
<p>Figuring out how the mechanism of line tracing works in CPython not only helps me to complete <a href="https://github.com/NaleRaphael/bytefall/blob/ee207a1e9e9fc40cd54f9ccac1e1cb61b12c27dc/bytefall/vm.py#L53-L97" target="_blank" rel="noopener">the part of bytecode dispatch</a> in <code>bytefall</code> VM, but also make it possible to run <code>pdb</code> in <code>bytefall</code> VM like the way it is used in a normal Python runtime.</p>
<p>But it’s just a part of implementation of this feature, we still need to make some modifications to make it work properly. If you are interested in it, you can also check out <a href="https://github.com/NaleRaphael/bytefall/blob/ee207a1e9e9fc40cd54f9ccac1e1cb61b12c27dc/bytefall/_compat/tracing.py#L28-L69" target="_blank" rel="noopener">this file</a> for the <code>Pdb</code> wrapper I wrote.</p>
<h2 id="further-reading"><a class="header-anchor" href="#further-reading"></a>Further reading</h2>
<p>If you are interested in this topic, I recommend you read this nice article: <a href="https://nedbatchelder.com/text/trace-function.html" target="_blank" rel="noopener">“How C trace functions really work - by Ned Batchelder”</a>.</p>

  </div>
</article>

    <div class="comments" id="comments">
        
    <script src="https://utteranc.es/client.js"
        repo="naleraphael/blog"
        issue-term="pathname"
        label="Comment"
        theme="icy-dark"
        crossorigin="anonymous"
        async>
    </script>


    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/about/">About</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="/blog/tags/">tags</a></li>
         
          <li><a href="/blog/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#when-you-call-pdb-set-trace"><span class="toc-number">1.</span> <span class="toc-text">When you call pdb.set_trace()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#take-a-look-at-the-huge-evaluation-loop"><span class="toc-number">2.</span> <span class="toc-text">Take a look at the huge evaluation loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#so-how-would-pdb-work-with-line-tracing"><span class="toc-number">3.</span> <span class="toc-text">So, how would pdb work with line tracing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#in-bytefall"><span class="toc-number">4.</span> <span class="toc-text">In bytefall…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#further-reading"><span class="toc-number">5.</span> <span class="toc-text">Further reading</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&text=Things behind `sys.settrace()`"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&is_video=false&description=Things behind `sys.settrace()`"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Things behind `sys.settrace()`&body=Check out this article: https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&title=Things behind `sys.settrace()`"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://naleraphael.github.io/posts/devlog_things_behind_sys_settrace/&name=Things behind `sys.settrace()`&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 naleraphael
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/blog/">Home</a></li>
         
          <li><a href="/blog/about/">About</a></li>
         
          <li><a href="/blog/archives/">Writing</a></li>
         
          <li><a href="/blog/tags/">tags</a></li>
         
          <li><a href="/blog/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/blog/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/blog/lib/jquery/jquery.min.js"></script>
<script src="/blog/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/blog/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>

<script src="/blog/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
